# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _CandidateStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CandidateStatus']]


class _CandidateStatusListFilterHasInput(TypedDict):
    has: 'enums.CandidateStatus'


class _CandidateStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CandidateStatus']


class _CandidateStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CandidateStatus']


class _CandidateStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CandidateStatusListFilter = Union[
    _CandidateStatusListFilterHasInput,
    _CandidateStatusListFilterEqualsInput,
    _CandidateStatusListFilterHasSomeInput,
    _CandidateStatusListFilterIsEmptyInput,
    _CandidateStatusListFilterHasEveryInput,
]


class _CandidateStatusListUpdateSet(TypedDict):
    set: List['enums.CandidateStatus']


class _CandidateStatusListUpdatePush(TypedDict):
    push: List['enums.CandidateStatus']


CandidateStatusListUpdate = Union[
    List['enums.CandidateStatus'],
    _CandidateStatusListUpdateSet,
    _CandidateStatusListUpdatePush,
]

class _CandidateCareerLevelListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CandidateCareerLevel']]


class _CandidateCareerLevelListFilterHasInput(TypedDict):
    has: 'enums.CandidateCareerLevel'


class _CandidateCareerLevelListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CandidateCareerLevel']


class _CandidateCareerLevelListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CandidateCareerLevel']


class _CandidateCareerLevelListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CandidateCareerLevelListFilter = Union[
    _CandidateCareerLevelListFilterHasInput,
    _CandidateCareerLevelListFilterEqualsInput,
    _CandidateCareerLevelListFilterHasSomeInput,
    _CandidateCareerLevelListFilterIsEmptyInput,
    _CandidateCareerLevelListFilterHasEveryInput,
]


class _CandidateCareerLevelListUpdateSet(TypedDict):
    set: List['enums.CandidateCareerLevel']


class _CandidateCareerLevelListUpdatePush(TypedDict):
    push: List['enums.CandidateCareerLevel']


CandidateCareerLevelListUpdate = Union[
    List['enums.CandidateCareerLevel'],
    _CandidateCareerLevelListUpdateSet,
    _CandidateCareerLevelListUpdatePush,
]

class _CandidateInterestListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CandidateInterest']]


class _CandidateInterestListFilterHasInput(TypedDict):
    has: 'enums.CandidateInterest'


class _CandidateInterestListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CandidateInterest']


class _CandidateInterestListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CandidateInterest']


class _CandidateInterestListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CandidateInterestListFilter = Union[
    _CandidateInterestListFilterHasInput,
    _CandidateInterestListFilterEqualsInput,
    _CandidateInterestListFilterHasSomeInput,
    _CandidateInterestListFilterIsEmptyInput,
    _CandidateInterestListFilterHasEveryInput,
]


class _CandidateInterestListUpdateSet(TypedDict):
    set: List['enums.CandidateInterest']


class _CandidateInterestListUpdatePush(TypedDict):
    push: List['enums.CandidateInterest']


CandidateInterestListUpdate = Union[
    List['enums.CandidateInterest'],
    _CandidateInterestListUpdateSet,
    _CandidateInterestListUpdatePush,
]

class _CompanyStageListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CompanyStage']]


class _CompanyStageListFilterHasInput(TypedDict):
    has: 'enums.CompanyStage'


class _CompanyStageListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CompanyStage']


class _CompanyStageListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CompanyStage']


class _CompanyStageListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CompanyStageListFilter = Union[
    _CompanyStageListFilterHasInput,
    _CompanyStageListFilterEqualsInput,
    _CompanyStageListFilterHasSomeInput,
    _CompanyStageListFilterIsEmptyInput,
    _CompanyStageListFilterHasEveryInput,
]


class _CompanyStageListUpdateSet(TypedDict):
    set: List['enums.CompanyStage']


class _CompanyStageListUpdatePush(TypedDict):
    push: List['enums.CompanyStage']


CompanyStageListUpdate = Union[
    List['enums.CompanyStage'],
    _CompanyStageListUpdateSet,
    _CompanyStageListUpdatePush,
]

class _JobStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.JobStatus']]


class _JobStatusListFilterHasInput(TypedDict):
    has: 'enums.JobStatus'


class _JobStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.JobStatus']


class _JobStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.JobStatus']


class _JobStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JobStatusListFilter = Union[
    _JobStatusListFilterHasInput,
    _JobStatusListFilterEqualsInput,
    _JobStatusListFilterHasSomeInput,
    _JobStatusListFilterIsEmptyInput,
    _JobStatusListFilterHasEveryInput,
]


class _JobStatusListUpdateSet(TypedDict):
    set: List['enums.JobStatus']


class _JobStatusListUpdatePush(TypedDict):
    push: List['enums.JobStatus']


JobStatusListUpdate = Union[
    List['enums.JobStatus'],
    _JobStatusListUpdateSet,
    _JobStatusListUpdatePush,
]

class _CompanySizeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CompanySize']]


class _CompanySizeListFilterHasInput(TypedDict):
    has: 'enums.CompanySize'


class _CompanySizeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CompanySize']


class _CompanySizeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CompanySize']


class _CompanySizeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CompanySizeListFilter = Union[
    _CompanySizeListFilterHasInput,
    _CompanySizeListFilterEqualsInput,
    _CompanySizeListFilterHasSomeInput,
    _CompanySizeListFilterIsEmptyInput,
    _CompanySizeListFilterHasEveryInput,
]


class _CompanySizeListUpdateSet(TypedDict):
    set: List['enums.CompanySize']


class _CompanySizeListUpdatePush(TypedDict):
    push: List['enums.CompanySize']


CompanySizeListUpdate = Union[
    List['enums.CompanySize'],
    _CompanySizeListUpdateSet,
    _CompanySizeListUpdatePush,
]

class _IndustryListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Industry']]


class _IndustryListFilterHasInput(TypedDict):
    has: 'enums.Industry'


class _IndustryListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Industry']


class _IndustryListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Industry']


class _IndustryListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IndustryListFilter = Union[
    _IndustryListFilterHasInput,
    _IndustryListFilterEqualsInput,
    _IndustryListFilterHasSomeInput,
    _IndustryListFilterIsEmptyInput,
    _IndustryListFilterHasEveryInput,
]


class _IndustryListUpdateSet(TypedDict):
    set: List['enums.Industry']


class _IndustryListUpdatePush(TypedDict):
    push: List['enums.Industry']


IndustryListUpdate = Union[
    List['enums.Industry'],
    _IndustryListUpdateSet,
    _IndustryListUpdatePush,
]


# Tenant types

class TenantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Tenant create method"""
    id: _str
    users: 'UserCreateManyNestedWithoutRelationsInput'
    candidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    companies: 'CompanyCreateManyNestedWithoutRelationsInput'
    searches: 'SearchCreateManyNestedWithoutRelationsInput'
    jobs: 'JobCreateManyNestedWithoutRelationsInput'
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    updatedBy: 'UserCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class TenantCreateInput(TenantOptionalCreateInput):
    """Required arguments to the Tenant create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TenantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Tenant create method, without relations"""
    id: _str
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class TenantCreateWithoutRelationsInput(TenantOptionalCreateWithoutRelationsInput):
    """Required arguments to the Tenant create method, without relations"""
    name: _str

class TenantConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TenantCreateWithoutRelationsInput'
    where: 'TenantWhereUniqueInput'

class TenantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TenantCreateWithoutRelationsInput'
    connect: 'TenantWhereUniqueInput'
    connect_or_create: 'TenantConnectOrCreateWithoutRelationsInput'


class TenantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TenantCreateWithoutRelationsInput', List['TenantCreateWithoutRelationsInput']]
    connect: Union['TenantWhereUniqueInput', List['TenantWhereUniqueInput']]
    connect_or_create: Union['TenantConnectOrCreateWithoutRelationsInput', List['TenantConnectOrCreateWithoutRelationsInput']]

_TenantWhereUnique_id_Input = TypedDict(
    '_TenantWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_TenantCompoundunique_tenant_nameKeyInner = TypedDict(
    '_TenantCompoundunique_tenant_nameKeyInner',
    {
        'name': '_str',
        'deletedAt': 'datetime.datetime',
    },
    total=True
)

_TenantCompoundunique_tenant_nameKey = TypedDict(
    '_TenantCompoundunique_tenant_nameKey',
    {
        'unique_tenant_name': '_TenantCompoundunique_tenant_nameKeyInner',
    },
    total=True
)

TenantWhereUniqueInput = Union[
    '_TenantWhereUnique_id_Input',
    '_TenantCompoundunique_tenant_nameKey',
]


class TenantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    users: 'UserUpdateManyWithoutRelationsInput'
    candidates: 'CandidateUpdateManyWithoutRelationsInput'
    companies: 'CompanyUpdateManyWithoutRelationsInput'
    searches: 'SearchUpdateManyWithoutRelationsInput'
    jobs: 'JobUpdateManyWithoutRelationsInput'
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    updatedBy: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class TenantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class TenantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TenantCreateWithoutRelationsInput']
    connect: List['TenantWhereUniqueInput']
    connect_or_create: List['TenantConnectOrCreateWithoutRelationsInput']
    set: List['TenantWhereUniqueInput']
    disconnect: List['TenantWhereUniqueInput']
    delete: List['TenantWhereUniqueInput']

    # TODO
    # update: List['TenantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TenantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TenantScalarWhereInput']
    # upsert: List['TenantUpserteWithWhereUniqueWithoutRelationsInput']


class TenantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TenantCreateWithoutRelationsInput'
    connect: 'TenantWhereUniqueInput'
    connect_or_create: 'TenantConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TenantUpdateInput'
    # upsert: 'TenantUpsertWithoutRelationsInput'


class TenantUpsertInput(TypedDict):
    create: 'TenantCreateInput'
    update: 'TenantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Tenant_id_OrderByInput = TypedDict(
    '_Tenant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Tenant_name_OrderByInput = TypedDict(
    '_Tenant_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Tenant_createdById_OrderByInput = TypedDict(
    '_Tenant_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_Tenant_updatedById_OrderByInput = TypedDict(
    '_Tenant_updatedById_OrderByInput',
    {
        'updatedById': 'SortOrder',
    },
    total=True
)

_Tenant_createdAt_OrderByInput = TypedDict(
    '_Tenant_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Tenant_updatedAt_OrderByInput = TypedDict(
    '_Tenant_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Tenant_deletedAt_OrderByInput = TypedDict(
    '_Tenant_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Tenant_deleted_OrderByInput = TypedDict(
    '_Tenant_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Tenant_RelevanceInner = TypedDict(
    '_Tenant_RelevanceInner',
    {
        'fields': 'List[TenantScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Tenant_RelevanceOrderByInput = TypedDict(
    '_Tenant_RelevanceOrderByInput',
    {
        '_relevance': '_Tenant_RelevanceInner',
    },
    total=True
)

TenantOrderByInput = Union[
    '_Tenant_id_OrderByInput',
    '_Tenant_name_OrderByInput',
    '_Tenant_createdById_OrderByInput',
    '_Tenant_updatedById_OrderByInput',
    '_Tenant_createdAt_OrderByInput',
    '_Tenant_updatedAt_OrderByInput',
    '_Tenant_deletedAt_OrderByInput',
    '_Tenant_deleted_OrderByInput',
    '_Tenant_RelevanceOrderByInput',
]



# recursive Tenant types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TenantRelationFilter = TypedDict(
    'TenantRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TenantListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TenantInclude(TypedDict, total=False):
    """Tenant relational arguments"""
    users: Union[bool, 'FindManyUserArgsFromTenant']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenant']
    companies: Union[bool, 'FindManyCompanyArgsFromTenant']
    searches: Union[bool, 'FindManySearchArgsFromTenant']
    jobs: Union[bool, 'FindManyJobArgsFromTenant']
    createdBy: Union[bool, 'UserArgsFromTenant']
    updatedBy: Union[bool, 'UserArgsFromTenant']


    

class TenantIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    users: Union[bool, 'FindManyUserArgsFromTenantRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive1']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive1']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive1']


class TenantIncludeFromTenantRecursive1(TypedDict, total=False):
    """Relational arguments for Tenant"""
    users: Union[bool, 'FindManyUserArgsFromTenantRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive2']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive2']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive2']


class TenantIncludeFromTenantRecursive2(TypedDict, total=False):
    """Relational arguments for Tenant"""
    users: Union[bool, 'FindManyUserArgsFromTenantRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive3']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive3']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive3']


class TenantIncludeFromTenantRecursive3(TypedDict, total=False):
    """Relational arguments for Tenant"""
    users: Union[bool, 'FindManyUserArgsFromTenantRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive4']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive4']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive4']


class TenantIncludeFromTenantRecursive4(TypedDict, total=False):
    """Relational arguments for Tenant"""

    

class TenantArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'TenantIncludeFromTenantRecursive1'


class TenantArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'TenantIncludeFromTenantRecursive2'


class TenantArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'TenantIncludeFromTenantRecursive3'


class TenantArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'TenantIncludeFromTenantRecursive4'


class TenantArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    
    

class FindManyTenantArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive1'


class FindManyTenantArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive2'


class FindManyTenantArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive3'


class FindManyTenantArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive4'


class FindManyTenantArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    
    

class UserIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive1']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive1']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive1']
    createdTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive1']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive1']
    createdUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive1']
    updatedUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive1']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']
    createdSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive1']
    updatedSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive1']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']
    createdJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive1']
    updatedJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive1']


class UserIncludeFromTenantRecursive1(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive2']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive2']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive2']
    createdTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive2']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive2']
    createdUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive2']
    updatedUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive2']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']
    createdSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive2']
    updatedSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive2']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']
    createdJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive2']
    updatedJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive2']


class UserIncludeFromTenantRecursive2(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive3']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive3']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive3']
    createdTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive3']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive3']
    createdUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive3']
    updatedUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive3']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']
    createdSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive3']
    updatedSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive3']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']
    createdJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive3']
    updatedJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive3']


class UserIncludeFromTenantRecursive3(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive4']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive4']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive4']
    createdTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive4']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromTenantRecursive4']
    createdUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive4']
    updatedUsers: Union[bool, 'FindManyUserArgsFromTenantRecursive4']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']
    createdSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive4']
    updatedSearches: Union[bool, 'FindManySearchArgsFromTenantRecursive4']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']
    createdJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive4']
    updatedJobs: Union[bool, 'FindManyJobArgsFromTenantRecursive4']


class UserIncludeFromTenantRecursive4(TypedDict, total=False):
    """Relational arguments for Tenant"""

    

class UserArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    
    

class FindManyUserArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class CandidateIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive1']
    user: Union[bool, 'UserArgsFromTenantRecursive1']
    lastTouchedBy: Union[bool, 'UserArgsFromTenantRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive1']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive1']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive1']


class CandidateIncludeFromTenantRecursive1(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive2']
    user: Union[bool, 'UserArgsFromTenantRecursive2']
    lastTouchedBy: Union[bool, 'UserArgsFromTenantRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive2']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive2']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive2']


class CandidateIncludeFromTenantRecursive2(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive3']
    user: Union[bool, 'UserArgsFromTenantRecursive3']
    lastTouchedBy: Union[bool, 'UserArgsFromTenantRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive3']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive3']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive3']


class CandidateIncludeFromTenantRecursive3(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive4']
    user: Union[bool, 'UserArgsFromTenantRecursive4']
    lastTouchedBy: Union[bool, 'UserArgsFromTenantRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromTenantRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromTenantRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive4']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive4']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive4']


class CandidateIncludeFromTenantRecursive4(TypedDict, total=False):
    """Relational arguments for Tenant"""

    

class CandidateArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CandidateIncludeFromCandidateRecursive1'


class CandidateArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CandidateIncludeFromCandidateRecursive2'


class CandidateArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CandidateIncludeFromCandidateRecursive3'


class CandidateArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CandidateIncludeFromCandidateRecursive4'


class CandidateArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    
    

class FindManyCandidateArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive1'


class FindManyCandidateArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive2'


class FindManyCandidateArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive3'


class FindManyCandidateArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive4'


class FindManyCandidateArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    
    

class SearchIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    user: Union[bool, 'UserArgsFromTenantRecursive1']
    tenant: Union[bool, 'TenantArgsFromTenantRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive1']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive1']


class SearchIncludeFromTenantRecursive1(TypedDict, total=False):
    """Relational arguments for Tenant"""
    user: Union[bool, 'UserArgsFromTenantRecursive2']
    tenant: Union[bool, 'TenantArgsFromTenantRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive2']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive2']


class SearchIncludeFromTenantRecursive2(TypedDict, total=False):
    """Relational arguments for Tenant"""
    user: Union[bool, 'UserArgsFromTenantRecursive3']
    tenant: Union[bool, 'TenantArgsFromTenantRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive3']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive3']


class SearchIncludeFromTenantRecursive3(TypedDict, total=False):
    """Relational arguments for Tenant"""
    user: Union[bool, 'UserArgsFromTenantRecursive4']
    tenant: Union[bool, 'TenantArgsFromTenantRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive4']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive4']


class SearchIncludeFromTenantRecursive4(TypedDict, total=False):
    """Relational arguments for Tenant"""

    

class SearchArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'SearchIncludeFromSearchRecursive1'


class SearchArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'SearchIncludeFromSearchRecursive2'


class SearchArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'SearchIncludeFromSearchRecursive3'


class SearchArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'SearchIncludeFromSearchRecursive4'


class SearchArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    
    

class FindManySearchArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive1'


class FindManySearchArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive2'


class FindManySearchArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive3'


class FindManySearchArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive4'


class FindManySearchArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    
    

class JobIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive1']
    user: Union[bool, 'UserArgsFromTenantRecursive1']
    company: Union[bool, 'CompanyArgsFromTenantRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive1']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive1']


class JobIncludeFromTenantRecursive1(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive2']
    user: Union[bool, 'UserArgsFromTenantRecursive2']
    company: Union[bool, 'CompanyArgsFromTenantRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive2']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive2']


class JobIncludeFromTenantRecursive2(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive3']
    user: Union[bool, 'UserArgsFromTenantRecursive3']
    company: Union[bool, 'CompanyArgsFromTenantRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive3']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive3']


class JobIncludeFromTenantRecursive3(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive4']
    user: Union[bool, 'UserArgsFromTenantRecursive4']
    company: Union[bool, 'CompanyArgsFromTenantRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']
    createdBy: Union[bool, 'UserArgsFromTenantRecursive4']
    updatedBy: Union[bool, 'UserArgsFromTenantRecursive4']


class JobIncludeFromTenantRecursive4(TypedDict, total=False):
    """Relational arguments for Tenant"""

    

class JobArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'JobIncludeFromJobRecursive1'


class JobArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'JobIncludeFromJobRecursive2'


class JobArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'JobIncludeFromJobRecursive3'


class JobArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'JobIncludeFromJobRecursive4'


class JobArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    
    

class FindManyJobArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive1'


class FindManyJobArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive2'


class FindManyJobArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive3'


class FindManyJobArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive4'


class FindManyJobArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    
    

class CompanyIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive1']


class CompanyIncludeFromTenantRecursive1(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive2']


class CompanyIncludeFromTenantRecursive2(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive3']


class CompanyIncludeFromTenantRecursive3(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenantRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromTenantRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenantRecursive4']


class CompanyIncludeFromTenantRecursive4(TypedDict, total=False):
    """Relational arguments for Tenant"""

    

class CompanyArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CompanyIncludeFromCompanyRecursive1'


class CompanyArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CompanyIncludeFromCompanyRecursive2'


class CompanyArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CompanyIncludeFromCompanyRecursive3'


class CompanyArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CompanyIncludeFromCompanyRecursive4'


class CompanyArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    
    

class FindManyCompanyArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive1'


class FindManyCompanyArgsFromTenantRecursive1(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive2'


class FindManyCompanyArgsFromTenantRecursive2(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive3'


class FindManyCompanyArgsFromTenantRecursive3(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive4'


class FindManyCompanyArgsFromTenantRecursive4(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    


FindManyTenantArgs = FindManyTenantArgsFromTenant
FindFirstTenantArgs = FindManyTenantArgsFromTenant


    

class TenantWhereInput(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    companies: 'CompanyListRelationFilter'
    searches: 'SearchListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['TenantWhereInputRecursive1', List['TenantWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TenantWhereInputRecursive1']
    OR: List['TenantWhereInputRecursive1']
    NOT: List['TenantWhereInputRecursive1']


class TenantWhereInputRecursive1(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    companies: 'CompanyListRelationFilter'
    searches: 'SearchListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['TenantWhereInputRecursive2', List['TenantWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TenantWhereInputRecursive2']
    OR: List['TenantWhereInputRecursive2']
    NOT: List['TenantWhereInputRecursive2']


class TenantWhereInputRecursive2(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    companies: 'CompanyListRelationFilter'
    searches: 'SearchListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['TenantWhereInputRecursive3', List['TenantWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TenantWhereInputRecursive3']
    OR: List['TenantWhereInputRecursive3']
    NOT: List['TenantWhereInputRecursive3']


class TenantWhereInputRecursive3(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    companies: 'CompanyListRelationFilter'
    searches: 'SearchListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['TenantWhereInputRecursive4', List['TenantWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TenantWhereInputRecursive4']
    OR: List['TenantWhereInputRecursive4']
    NOT: List['TenantWhereInputRecursive4']


class TenantWhereInputRecursive4(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    companies: 'CompanyListRelationFilter'
    searches: 'SearchListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']



# aggregate Tenant types


    

class TenantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['TenantScalarWhereWithAggregatesInputRecursive1']
    OR: List['TenantScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TenantScalarWhereWithAggregatesInputRecursive1']


class TenantScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['TenantScalarWhereWithAggregatesInputRecursive2']
    OR: List['TenantScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TenantScalarWhereWithAggregatesInputRecursive2']


class TenantScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['TenantScalarWhereWithAggregatesInputRecursive3']
    OR: List['TenantScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TenantScalarWhereWithAggregatesInputRecursive3']


class TenantScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['TenantScalarWhereWithAggregatesInputRecursive4']
    OR: List['TenantScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TenantScalarWhereWithAggregatesInputRecursive4']


class TenantScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']



class TenantGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool
    _sum: 'TenantSumAggregateOutput'
    _avg: 'TenantAvgAggregateOutput'
    _min: 'TenantMinAggregateOutput'
    _max: 'TenantMaxAggregateOutput'
    _count: 'TenantCountAggregateOutput'


class TenantAvgAggregateOutput(TypedDict, total=False):
    """Tenant output for aggregating averages"""


class TenantSumAggregateOutput(TypedDict, total=False):
    """Tenant output for aggregating sums"""


class TenantScalarAggregateOutput(TypedDict, total=False):
    """Tenant output including scalar fields"""
    id: _str
    name: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool


TenantMinAggregateOutput = TenantScalarAggregateOutput
TenantMaxAggregateOutput = TenantScalarAggregateOutput


class TenantMaxAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating by max"""
    id: bool
    name: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class TenantMinAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating by min"""
    id: bool
    name: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class TenantNumberAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating numbers"""


TenantAvgAggregateInput = TenantNumberAggregateInput
TenantSumAggregateInput = TenantNumberAggregateInput


TenantCountAggregateInput = TypedDict(
    'TenantCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'createdById': bool,
        'updatedById': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deletedAt': bool,
        'deleted': bool,
        '_all': bool,
    },
    total=False,
)

TenantCountAggregateOutput = TypedDict(
    'TenantCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'createdById': int,
        'updatedById': int,
        'createdAt': int,
        'updatedAt': int,
        'deletedAt': int,
        'deleted': int,
        '_all': int,
    },
    total=False,
)


TenantKeys = Literal[
    'id',
    'name',
    'users',
    'candidates',
    'companies',
    'searches',
    'jobs',
    'createdById',
    'updatedById',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
TenantScalarFieldKeys = Literal[
    'id',
    'name',
    'createdById',
    'updatedById',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
TenantScalarFieldKeysT = TypeVar('TenantScalarFieldKeysT', bound=TenantScalarFieldKeys)

TenantRelationalFieldKeys = Literal[
        'users',
        'candidates',
        'companies',
        'searches',
        'jobs',
        'createdBy',
        'updatedBy',
    ]

# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    name: Optional[_str]
    tenantId: _str
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    searches: 'SearchCreateManyNestedWithoutRelationsInput'
    candidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    jobs: 'JobCreateManyNestedWithoutRelationsInput'
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    updatedBy: 'UserCreateNestedWithoutRelationsInput'
    createdTenants: 'TenantCreateManyNestedWithoutRelationsInput'
    updatedTenants: 'TenantCreateManyNestedWithoutRelationsInput'
    createdUsers: 'UserCreateManyNestedWithoutRelationsInput'
    updatedUsers: 'UserCreateManyNestedWithoutRelationsInput'
    createdCandidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    updatedCandidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    createdSearches: 'SearchCreateManyNestedWithoutRelationsInput'
    updatedSearches: 'SearchCreateManyNestedWithoutRelationsInput'
    touchedCandidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    createdJobs: 'JobCreateManyNestedWithoutRelationsInput'
    updatedJobs: 'JobCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    name: Optional[_str]
    tenantId: _str
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_UserCompoundunique_user_email_tenantKeyInner = TypedDict(
    '_UserCompoundunique_user_email_tenantKeyInner',
    {
        'tenantId': '_str',
        'email': '_str',
        'deletedAt': 'datetime.datetime',
    },
    total=True
)

_UserCompoundunique_user_email_tenantKey = TypedDict(
    '_UserCompoundunique_user_email_tenantKey',
    {
        'unique_user_email_tenant': '_UserCompoundunique_user_email_tenantKeyInner',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
    '_UserCompoundunique_user_email_tenantKey',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    email: _str
    name: Optional[_str]
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    searches: 'SearchUpdateManyWithoutRelationsInput'
    candidates: 'CandidateUpdateManyWithoutRelationsInput'
    jobs: 'JobUpdateManyWithoutRelationsInput'
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    updatedBy: 'UserUpdateOneWithoutRelationsInput'
    createdTenants: 'TenantUpdateManyWithoutRelationsInput'
    updatedTenants: 'TenantUpdateManyWithoutRelationsInput'
    createdUsers: 'UserUpdateManyWithoutRelationsInput'
    updatedUsers: 'UserUpdateManyWithoutRelationsInput'
    createdCandidates: 'CandidateUpdateManyWithoutRelationsInput'
    updatedCandidates: 'CandidateUpdateManyWithoutRelationsInput'
    createdSearches: 'SearchUpdateManyWithoutRelationsInput'
    updatedSearches: 'SearchUpdateManyWithoutRelationsInput'
    touchedCandidates: 'CandidateUpdateManyWithoutRelationsInput'
    createdJobs: 'JobUpdateManyWithoutRelationsInput'
    updatedJobs: 'JobUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    email: _str
    name: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_tenantId_OrderByInput = TypedDict(
    '_User_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_User_createdById_OrderByInput = TypedDict(
    '_User_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_User_updatedById_OrderByInput = TypedDict(
    '_User_updatedById_OrderByInput',
    {
        'updatedById': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_User_deletedAt_OrderByInput = TypedDict(
    '_User_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_User_deleted_OrderByInput = TypedDict(
    '_User_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_name_OrderByInput',
    '_User_tenantId_OrderByInput',
    '_User_createdById_OrderByInput',
    '_User_updatedById_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
    '_User_deletedAt_OrderByInput',
    '_User_deleted_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    tenant: Union[bool, 'TenantArgsFromUser']
    searches: Union[bool, 'FindManySearchArgsFromUser']
    candidates: Union[bool, 'FindManyCandidateArgsFromUser']
    jobs: Union[bool, 'FindManyJobArgsFromUser']
    createdBy: Union[bool, 'UserArgsFromUser']
    updatedBy: Union[bool, 'UserArgsFromUser']
    createdTenants: Union[bool, 'FindManyTenantArgsFromUser']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromUser']
    createdUsers: Union[bool, 'FindManyUserArgsFromUser']
    updatedUsers: Union[bool, 'FindManyUserArgsFromUser']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromUser']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromUser']
    createdSearches: Union[bool, 'FindManySearchArgsFromUser']
    updatedSearches: Union[bool, 'FindManySearchArgsFromUser']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromUser']
    createdJobs: Union[bool, 'FindManyJobArgsFromUser']
    updatedJobs: Union[bool, 'FindManyJobArgsFromUser']


    

class TenantIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive1']
    createdBy: Union[bool, 'UserArgsFromUserRecursive1']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive1']


class TenantIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive2']
    createdBy: Union[bool, 'UserArgsFromUserRecursive2']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive2']


class TenantIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive3']
    createdBy: Union[bool, 'UserArgsFromUserRecursive3']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive3']


class TenantIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUserRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive4']
    createdBy: Union[bool, 'UserArgsFromUserRecursive4']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive4']


class TenantIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class TenantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TenantIncludeFromTenantRecursive1'


class TenantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'TenantIncludeFromTenantRecursive2'


class TenantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'TenantIncludeFromTenantRecursive3'


class TenantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'TenantIncludeFromTenantRecursive4'


class TenantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyTenantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive1'


class FindManyTenantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive2'


class FindManyTenantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive3'


class FindManyTenantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive4'


class FindManyTenantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    
    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive1']
    createdBy: Union[bool, 'UserArgsFromUserRecursive1']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive1']
    createdTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive1']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive1']
    createdUsers: Union[bool, 'FindManyUserArgsFromUserRecursive1']
    updatedUsers: Union[bool, 'FindManyUserArgsFromUserRecursive1']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']
    createdSearches: Union[bool, 'FindManySearchArgsFromUserRecursive1']
    updatedSearches: Union[bool, 'FindManySearchArgsFromUserRecursive1']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']
    createdJobs: Union[bool, 'FindManyJobArgsFromUserRecursive1']
    updatedJobs: Union[bool, 'FindManyJobArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive2']
    createdBy: Union[bool, 'UserArgsFromUserRecursive2']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive2']
    createdTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive2']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive2']
    createdUsers: Union[bool, 'FindManyUserArgsFromUserRecursive2']
    updatedUsers: Union[bool, 'FindManyUserArgsFromUserRecursive2']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']
    createdSearches: Union[bool, 'FindManySearchArgsFromUserRecursive2']
    updatedSearches: Union[bool, 'FindManySearchArgsFromUserRecursive2']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']
    createdJobs: Union[bool, 'FindManyJobArgsFromUserRecursive2']
    updatedJobs: Union[bool, 'FindManyJobArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive3']
    createdBy: Union[bool, 'UserArgsFromUserRecursive3']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive3']
    createdTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive3']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive3']
    createdUsers: Union[bool, 'FindManyUserArgsFromUserRecursive3']
    updatedUsers: Union[bool, 'FindManyUserArgsFromUserRecursive3']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']
    createdSearches: Union[bool, 'FindManySearchArgsFromUserRecursive3']
    updatedSearches: Union[bool, 'FindManySearchArgsFromUserRecursive3']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']
    createdJobs: Union[bool, 'FindManyJobArgsFromUserRecursive3']
    updatedJobs: Union[bool, 'FindManyJobArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive4']
    createdBy: Union[bool, 'UserArgsFromUserRecursive4']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive4']
    createdTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive4']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromUserRecursive4']
    createdUsers: Union[bool, 'FindManyUserArgsFromUserRecursive4']
    updatedUsers: Union[bool, 'FindManyUserArgsFromUserRecursive4']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']
    createdSearches: Union[bool, 'FindManySearchArgsFromUserRecursive4']
    updatedSearches: Union[bool, 'FindManySearchArgsFromUserRecursive4']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']
    createdJobs: Union[bool, 'FindManyJobArgsFromUserRecursive4']
    updatedJobs: Union[bool, 'FindManyJobArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class CandidateIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive1']
    user: Union[bool, 'UserArgsFromUserRecursive1']
    lastTouchedBy: Union[bool, 'UserArgsFromUserRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive1']
    createdBy: Union[bool, 'UserArgsFromUserRecursive1']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive1']


class CandidateIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive2']
    user: Union[bool, 'UserArgsFromUserRecursive2']
    lastTouchedBy: Union[bool, 'UserArgsFromUserRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive2']
    createdBy: Union[bool, 'UserArgsFromUserRecursive2']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive2']


class CandidateIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive3']
    user: Union[bool, 'UserArgsFromUserRecursive3']
    lastTouchedBy: Union[bool, 'UserArgsFromUserRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive3']
    createdBy: Union[bool, 'UserArgsFromUserRecursive3']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive3']


class CandidateIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive4']
    user: Union[bool, 'UserArgsFromUserRecursive4']
    lastTouchedBy: Union[bool, 'UserArgsFromUserRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromUserRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromUserRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive4']
    createdBy: Union[bool, 'UserArgsFromUserRecursive4']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive4']


class CandidateIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CandidateArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CandidateIncludeFromCandidateRecursive1'


class CandidateArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CandidateIncludeFromCandidateRecursive2'


class CandidateArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CandidateIncludeFromCandidateRecursive3'


class CandidateArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CandidateIncludeFromCandidateRecursive4'


class CandidateArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCandidateArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive1'


class FindManyCandidateArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive2'


class FindManyCandidateArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive3'


class FindManyCandidateArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive4'


class FindManyCandidateArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    
    

class SearchIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    tenant: Union[bool, 'TenantArgsFromUserRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']
    createdBy: Union[bool, 'UserArgsFromUserRecursive1']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive1']


class SearchIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    tenant: Union[bool, 'TenantArgsFromUserRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']
    createdBy: Union[bool, 'UserArgsFromUserRecursive2']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive2']


class SearchIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    tenant: Union[bool, 'TenantArgsFromUserRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']
    createdBy: Union[bool, 'UserArgsFromUserRecursive3']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive3']


class SearchIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    tenant: Union[bool, 'TenantArgsFromUserRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']
    createdBy: Union[bool, 'UserArgsFromUserRecursive4']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive4']


class SearchIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class SearchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SearchIncludeFromSearchRecursive1'


class SearchArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'SearchIncludeFromSearchRecursive2'


class SearchArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'SearchIncludeFromSearchRecursive3'


class SearchArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'SearchIncludeFromSearchRecursive4'


class SearchArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManySearchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive1'


class FindManySearchArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive2'


class FindManySearchArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive3'


class FindManySearchArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive4'


class FindManySearchArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    
    

class JobIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive1']
    user: Union[bool, 'UserArgsFromUserRecursive1']
    company: Union[bool, 'CompanyArgsFromUserRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']
    createdBy: Union[bool, 'UserArgsFromUserRecursive1']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive1']


class JobIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive2']
    user: Union[bool, 'UserArgsFromUserRecursive2']
    company: Union[bool, 'CompanyArgsFromUserRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']
    createdBy: Union[bool, 'UserArgsFromUserRecursive2']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive2']


class JobIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive3']
    user: Union[bool, 'UserArgsFromUserRecursive3']
    company: Union[bool, 'CompanyArgsFromUserRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']
    createdBy: Union[bool, 'UserArgsFromUserRecursive3']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive3']


class JobIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive4']
    user: Union[bool, 'UserArgsFromUserRecursive4']
    company: Union[bool, 'CompanyArgsFromUserRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']
    createdBy: Union[bool, 'UserArgsFromUserRecursive4']
    updatedBy: Union[bool, 'UserArgsFromUserRecursive4']


class JobIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class JobArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'JobIncludeFromJobRecursive1'


class JobArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'JobIncludeFromJobRecursive2'


class JobArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'JobIncludeFromJobRecursive3'


class JobArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'JobIncludeFromJobRecursive4'


class JobArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyJobArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive1'


class FindManyJobArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive2'


class FindManyJobArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive3'


class FindManyJobArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive4'


class FindManyJobArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    
    

class CompanyIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive1']


class CompanyIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive2']


class CompanyIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive3']


class CompanyIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUserRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromUserRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRecursive4']


class CompanyIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CompanyArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CompanyIncludeFromCompanyRecursive1'


class CompanyArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CompanyIncludeFromCompanyRecursive2'


class CompanyArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CompanyIncludeFromCompanyRecursive3'


class CompanyArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CompanyIncludeFromCompanyRecursive4'


class CompanyArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCompanyArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive1'


class FindManyCompanyArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive2'


class FindManyCompanyArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive3'


class FindManyCompanyArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive4'


class FindManyCompanyArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    searches: 'SearchListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdTenants: 'TenantListRelationFilter'
    updatedTenants: 'TenantListRelationFilter'
    createdUsers: 'UserListRelationFilter'
    updatedUsers: 'UserListRelationFilter'
    createdCandidates: 'CandidateListRelationFilter'
    updatedCandidates: 'CandidateListRelationFilter'
    createdSearches: 'SearchListRelationFilter'
    updatedSearches: 'SearchListRelationFilter'
    touchedCandidates: 'CandidateListRelationFilter'
    createdJobs: 'JobListRelationFilter'
    updatedJobs: 'JobListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    searches: 'SearchListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdTenants: 'TenantListRelationFilter'
    updatedTenants: 'TenantListRelationFilter'
    createdUsers: 'UserListRelationFilter'
    updatedUsers: 'UserListRelationFilter'
    createdCandidates: 'CandidateListRelationFilter'
    updatedCandidates: 'CandidateListRelationFilter'
    createdSearches: 'SearchListRelationFilter'
    updatedSearches: 'SearchListRelationFilter'
    touchedCandidates: 'CandidateListRelationFilter'
    createdJobs: 'JobListRelationFilter'
    updatedJobs: 'JobListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    searches: 'SearchListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdTenants: 'TenantListRelationFilter'
    updatedTenants: 'TenantListRelationFilter'
    createdUsers: 'UserListRelationFilter'
    updatedUsers: 'UserListRelationFilter'
    createdCandidates: 'CandidateListRelationFilter'
    updatedCandidates: 'CandidateListRelationFilter'
    createdSearches: 'SearchListRelationFilter'
    updatedSearches: 'SearchListRelationFilter'
    touchedCandidates: 'CandidateListRelationFilter'
    createdJobs: 'JobListRelationFilter'
    updatedJobs: 'JobListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    searches: 'SearchListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdTenants: 'TenantListRelationFilter'
    updatedTenants: 'TenantListRelationFilter'
    createdUsers: 'UserListRelationFilter'
    updatedUsers: 'UserListRelationFilter'
    createdCandidates: 'CandidateListRelationFilter'
    updatedCandidates: 'CandidateListRelationFilter'
    createdSearches: 'SearchListRelationFilter'
    updatedSearches: 'SearchListRelationFilter'
    touchedCandidates: 'CandidateListRelationFilter'
    createdJobs: 'JobListRelationFilter'
    updatedJobs: 'JobListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    searches: 'SearchListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdTenants: 'TenantListRelationFilter'
    updatedTenants: 'TenantListRelationFilter'
    createdUsers: 'UserListRelationFilter'
    updatedUsers: 'UserListRelationFilter'
    createdCandidates: 'CandidateListRelationFilter'
    updatedCandidates: 'CandidateListRelationFilter'
    createdSearches: 'SearchListRelationFilter'
    updatedSearches: 'SearchListRelationFilter'
    touchedCandidates: 'CandidateListRelationFilter'
    createdJobs: 'JobListRelationFilter'
    updatedJobs: 'JobListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    email: _str
    name: _str
    tenantId: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    email: _str
    name: _str
    tenantId: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    name: bool
    tenantId: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    name: bool
    tenantId: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'name': bool,
        'tenantId': bool,
        'createdById': bool,
        'updatedById': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deletedAt': bool,
        'deleted': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'name': int,
        'tenantId': int,
        'createdById': int,
        'updatedById': int,
        'createdAt': int,
        'updatedAt': int,
        'deletedAt': int,
        'deleted': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'name',
    'tenantId',
    'tenant',
    'searches',
    'candidates',
    'jobs',
    'createdById',
    'updatedById',
    'createdBy',
    'updatedBy',
    'createdTenants',
    'updatedTenants',
    'createdUsers',
    'updatedUsers',
    'createdCandidates',
    'updatedCandidates',
    'createdSearches',
    'updatedSearches',
    'touchedCandidates',
    'createdJobs',
    'updatedJobs',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'name',
    'tenantId',
    'createdById',
    'updatedById',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'tenant',
        'searches',
        'candidates',
        'jobs',
        'createdBy',
        'updatedBy',
        'createdTenants',
        'updatedTenants',
        'createdUsers',
        'updatedUsers',
        'createdCandidates',
        'updatedCandidates',
        'createdSearches',
        'updatedSearches',
        'touchedCandidates',
        'createdJobs',
        'updatedJobs',
    ]

# Candidate types

class CandidateOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Candidate create method"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    linkedin: Optional[_str]
    github: Optional[_str]
    website: Optional[_str]
    phone: Optional[_str]
    location: Optional[_str]
    status: Optional['enums.CandidateStatus']
    interest: Optional['enums.CandidateInterest']
    careerLevel: Optional['enums.CandidateCareerLevel']
    resume: Optional[_str]
    source: Optional[_str]
    profile: Optional['fields.Json']
    notes: Optional[_str]
    lastTouched: Optional[datetime.datetime]
    tenantId: _str
    userId: _str
    lastTouchedById: Optional[_str]
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    user: 'UserCreateNestedWithoutRelationsInput'
    lastTouchedBy: 'UserCreateNestedWithoutRelationsInput'
    searches: 'SearchCreateManyNestedWithoutRelationsInput'
    companies: 'CompanyCreateManyNestedWithoutRelationsInput'
    jobs: 'JobCreateManyNestedWithoutRelationsInput'
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    updatedBy: 'UserCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CandidateCreateInput(CandidateOptionalCreateInput):
    """Required arguments to the Candidate create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CandidateOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Candidate create method, without relations"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    linkedin: Optional[_str]
    github: Optional[_str]
    website: Optional[_str]
    phone: Optional[_str]
    location: Optional[_str]
    status: Optional['enums.CandidateStatus']
    interest: Optional['enums.CandidateInterest']
    careerLevel: Optional['enums.CandidateCareerLevel']
    resume: Optional[_str]
    source: Optional[_str]
    profile: Optional['fields.Json']
    notes: Optional[_str]
    lastTouched: Optional[datetime.datetime]
    tenantId: _str
    userId: _str
    lastTouchedById: Optional[_str]
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CandidateCreateWithoutRelationsInput(CandidateOptionalCreateWithoutRelationsInput):
    """Required arguments to the Candidate create method, without relations"""

class CandidateConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CandidateCreateWithoutRelationsInput'
    where: 'CandidateWhereUniqueInput'

class CandidateCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CandidateCreateWithoutRelationsInput'
    connect: 'CandidateWhereUniqueInput'
    connect_or_create: 'CandidateConnectOrCreateWithoutRelationsInput'


class CandidateCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CandidateCreateWithoutRelationsInput', List['CandidateCreateWithoutRelationsInput']]
    connect: Union['CandidateWhereUniqueInput', List['CandidateWhereUniqueInput']]
    connect_or_create: Union['CandidateConnectOrCreateWithoutRelationsInput', List['CandidateConnectOrCreateWithoutRelationsInput']]

_CandidateWhereUnique_id_Input = TypedDict(
    '_CandidateWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_CandidateWhereUnique_email_Input = TypedDict(
    '_CandidateWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_CandidateCompoundunique_candidate_emailKeyInner = TypedDict(
    '_CandidateCompoundunique_candidate_emailKeyInner',
    {
        'tenantId': '_str',
        'email': '_str',
        'deletedAt': 'datetime.datetime',
    },
    total=True
)

_CandidateCompoundunique_candidate_emailKey = TypedDict(
    '_CandidateCompoundunique_candidate_emailKey',
    {
        'unique_candidate_email': '_CandidateCompoundunique_candidate_emailKeyInner',
    },
    total=True
)

CandidateWhereUniqueInput = Union[
    '_CandidateWhereUnique_id_Input',
    '_CandidateWhereUnique_email_Input',
    '_CandidateCompoundunique_candidate_emailKey',
]


class CandidateUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    linkedin: Optional[_str]
    github: Optional[_str]
    website: Optional[_str]
    phone: Optional[_str]
    location: Optional[_str]
    status: Optional['enums.CandidateStatus']
    interest: Optional['enums.CandidateInterest']
    careerLevel: Optional['enums.CandidateCareerLevel']
    resume: Optional[_str]
    source: Optional[_str]
    profile: Optional['fields.Json']
    notes: Optional[_str]
    lastTouched: Optional[datetime.datetime]
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    user: 'UserUpdateOneWithoutRelationsInput'
    lastTouchedBy: 'UserUpdateOneWithoutRelationsInput'
    searches: 'SearchUpdateManyWithoutRelationsInput'
    companies: 'CompanyUpdateManyWithoutRelationsInput'
    jobs: 'JobUpdateManyWithoutRelationsInput'
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    updatedBy: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CandidateUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    linkedin: Optional[_str]
    github: Optional[_str]
    website: Optional[_str]
    phone: Optional[_str]
    location: Optional[_str]
    status: Optional['enums.CandidateStatus']
    interest: Optional['enums.CandidateInterest']
    careerLevel: Optional['enums.CandidateCareerLevel']
    resume: Optional[_str]
    source: Optional[_str]
    profile: Optional['fields.Json']
    notes: Optional[_str]
    lastTouched: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CandidateUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CandidateCreateWithoutRelationsInput']
    connect: List['CandidateWhereUniqueInput']
    connect_or_create: List['CandidateConnectOrCreateWithoutRelationsInput']
    set: List['CandidateWhereUniqueInput']
    disconnect: List['CandidateWhereUniqueInput']
    delete: List['CandidateWhereUniqueInput']

    # TODO
    # update: List['CandidateUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CandidateUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CandidateScalarWhereInput']
    # upsert: List['CandidateUpserteWithWhereUniqueWithoutRelationsInput']


class CandidateUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CandidateCreateWithoutRelationsInput'
    connect: 'CandidateWhereUniqueInput'
    connect_or_create: 'CandidateConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CandidateUpdateInput'
    # upsert: 'CandidateUpsertWithoutRelationsInput'


class CandidateUpsertInput(TypedDict):
    create: 'CandidateCreateInput'
    update: 'CandidateUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Candidate_id_OrderByInput = TypedDict(
    '_Candidate_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Candidate_name_OrderByInput = TypedDict(
    '_Candidate_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Candidate_email_OrderByInput = TypedDict(
    '_Candidate_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Candidate_linkedin_OrderByInput = TypedDict(
    '_Candidate_linkedin_OrderByInput',
    {
        'linkedin': 'SortOrder',
    },
    total=True
)

_Candidate_github_OrderByInput = TypedDict(
    '_Candidate_github_OrderByInput',
    {
        'github': 'SortOrder',
    },
    total=True
)

_Candidate_website_OrderByInput = TypedDict(
    '_Candidate_website_OrderByInput',
    {
        'website': 'SortOrder',
    },
    total=True
)

_Candidate_phone_OrderByInput = TypedDict(
    '_Candidate_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Candidate_location_OrderByInput = TypedDict(
    '_Candidate_location_OrderByInput',
    {
        'location': 'SortOrder',
    },
    total=True
)

_Candidate_status_OrderByInput = TypedDict(
    '_Candidate_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Candidate_interest_OrderByInput = TypedDict(
    '_Candidate_interest_OrderByInput',
    {
        'interest': 'SortOrder',
    },
    total=True
)

_Candidate_careerLevel_OrderByInput = TypedDict(
    '_Candidate_careerLevel_OrderByInput',
    {
        'careerLevel': 'SortOrder',
    },
    total=True
)

_Candidate_resume_OrderByInput = TypedDict(
    '_Candidate_resume_OrderByInput',
    {
        'resume': 'SortOrder',
    },
    total=True
)

_Candidate_source_OrderByInput = TypedDict(
    '_Candidate_source_OrderByInput',
    {
        'source': 'SortOrder',
    },
    total=True
)

_Candidate_profile_OrderByInput = TypedDict(
    '_Candidate_profile_OrderByInput',
    {
        'profile': 'SortOrder',
    },
    total=True
)

_Candidate_notes_OrderByInput = TypedDict(
    '_Candidate_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_Candidate_lastTouched_OrderByInput = TypedDict(
    '_Candidate_lastTouched_OrderByInput',
    {
        'lastTouched': 'SortOrder',
    },
    total=True
)

_Candidate_tenantId_OrderByInput = TypedDict(
    '_Candidate_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Candidate_userId_OrderByInput = TypedDict(
    '_Candidate_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Candidate_lastTouchedById_OrderByInput = TypedDict(
    '_Candidate_lastTouchedById_OrderByInput',
    {
        'lastTouchedById': 'SortOrder',
    },
    total=True
)

_Candidate_createdById_OrderByInput = TypedDict(
    '_Candidate_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_Candidate_updatedById_OrderByInput = TypedDict(
    '_Candidate_updatedById_OrderByInput',
    {
        'updatedById': 'SortOrder',
    },
    total=True
)

_Candidate_createdAt_OrderByInput = TypedDict(
    '_Candidate_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Candidate_updatedAt_OrderByInput = TypedDict(
    '_Candidate_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Candidate_deletedAt_OrderByInput = TypedDict(
    '_Candidate_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Candidate_deleted_OrderByInput = TypedDict(
    '_Candidate_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Candidate_RelevanceInner = TypedDict(
    '_Candidate_RelevanceInner',
    {
        'fields': 'List[CandidateScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Candidate_RelevanceOrderByInput = TypedDict(
    '_Candidate_RelevanceOrderByInput',
    {
        '_relevance': '_Candidate_RelevanceInner',
    },
    total=True
)

CandidateOrderByInput = Union[
    '_Candidate_id_OrderByInput',
    '_Candidate_name_OrderByInput',
    '_Candidate_email_OrderByInput',
    '_Candidate_linkedin_OrderByInput',
    '_Candidate_github_OrderByInput',
    '_Candidate_website_OrderByInput',
    '_Candidate_phone_OrderByInput',
    '_Candidate_location_OrderByInput',
    '_Candidate_status_OrderByInput',
    '_Candidate_interest_OrderByInput',
    '_Candidate_careerLevel_OrderByInput',
    '_Candidate_resume_OrderByInput',
    '_Candidate_source_OrderByInput',
    '_Candidate_profile_OrderByInput',
    '_Candidate_notes_OrderByInput',
    '_Candidate_lastTouched_OrderByInput',
    '_Candidate_tenantId_OrderByInput',
    '_Candidate_userId_OrderByInput',
    '_Candidate_lastTouchedById_OrderByInput',
    '_Candidate_createdById_OrderByInput',
    '_Candidate_updatedById_OrderByInput',
    '_Candidate_createdAt_OrderByInput',
    '_Candidate_updatedAt_OrderByInput',
    '_Candidate_deletedAt_OrderByInput',
    '_Candidate_deleted_OrderByInput',
    '_Candidate_RelevanceOrderByInput',
]



# recursive Candidate types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CandidateRelationFilter = TypedDict(
    'CandidateRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CandidateListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CandidateInclude(TypedDict, total=False):
    """Candidate relational arguments"""
    tenant: Union[bool, 'TenantArgsFromCandidate']
    user: Union[bool, 'UserArgsFromCandidate']
    lastTouchedBy: Union[bool, 'UserArgsFromCandidate']
    searches: Union[bool, 'FindManySearchArgsFromCandidate']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidate']
    jobs: Union[bool, 'FindManyJobArgsFromCandidate']
    createdBy: Union[bool, 'UserArgsFromCandidate']
    updatedBy: Union[bool, 'UserArgsFromCandidate']


    

class TenantIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    users: Union[bool, 'FindManyUserArgsFromCandidateRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive1']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive1']


class TenantIncludeFromCandidateRecursive1(TypedDict, total=False):
    """Relational arguments for Candidate"""
    users: Union[bool, 'FindManyUserArgsFromCandidateRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive2']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive2']


class TenantIncludeFromCandidateRecursive2(TypedDict, total=False):
    """Relational arguments for Candidate"""
    users: Union[bool, 'FindManyUserArgsFromCandidateRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive3']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive3']


class TenantIncludeFromCandidateRecursive3(TypedDict, total=False):
    """Relational arguments for Candidate"""
    users: Union[bool, 'FindManyUserArgsFromCandidateRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive4']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive4']


class TenantIncludeFromCandidateRecursive4(TypedDict, total=False):
    """Relational arguments for Candidate"""

    

class TenantArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'TenantIncludeFromTenantRecursive1'


class TenantArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'TenantIncludeFromTenantRecursive2'


class TenantArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'TenantIncludeFromTenantRecursive3'


class TenantArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'TenantIncludeFromTenantRecursive4'


class TenantArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    
    

class FindManyTenantArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive1'


class FindManyTenantArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive2'


class FindManyTenantArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive3'


class FindManyTenantArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive4'


class FindManyTenantArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    
    

class UserIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive1']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive1']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive1']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive1']
    createdUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive1']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive1']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']
    createdSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive1']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive1']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']
    createdJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive1']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive1']


class UserIncludeFromCandidateRecursive1(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive2']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive2']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive2']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive2']
    createdUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive2']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive2']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']
    createdSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive2']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive2']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']
    createdJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive2']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive2']


class UserIncludeFromCandidateRecursive2(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive3']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive3']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive3']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive3']
    createdUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive3']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive3']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']
    createdSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive3']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive3']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']
    createdJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive3']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive3']


class UserIncludeFromCandidateRecursive3(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive4']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive4']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive4']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCandidateRecursive4']
    createdUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive4']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCandidateRecursive4']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']
    createdSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive4']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCandidateRecursive4']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']
    createdJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive4']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive4']


class UserIncludeFromCandidateRecursive4(TypedDict, total=False):
    """Relational arguments for Candidate"""

    

class UserArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    
    

class FindManyUserArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class CandidateIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive1']
    user: Union[bool, 'UserArgsFromCandidateRecursive1']
    lastTouchedBy: Union[bool, 'UserArgsFromCandidateRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive1']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive1']


class CandidateIncludeFromCandidateRecursive1(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive2']
    user: Union[bool, 'UserArgsFromCandidateRecursive2']
    lastTouchedBy: Union[bool, 'UserArgsFromCandidateRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive2']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive2']


class CandidateIncludeFromCandidateRecursive2(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive3']
    user: Union[bool, 'UserArgsFromCandidateRecursive3']
    lastTouchedBy: Union[bool, 'UserArgsFromCandidateRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive3']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive3']


class CandidateIncludeFromCandidateRecursive3(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive4']
    user: Union[bool, 'UserArgsFromCandidateRecursive4']
    lastTouchedBy: Union[bool, 'UserArgsFromCandidateRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromCandidateRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromCandidateRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive4']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive4']


class CandidateIncludeFromCandidateRecursive4(TypedDict, total=False):
    """Relational arguments for Candidate"""

    

class CandidateArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CandidateIncludeFromCandidateRecursive1'


class CandidateArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CandidateIncludeFromCandidateRecursive2'


class CandidateArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CandidateIncludeFromCandidateRecursive3'


class CandidateArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CandidateIncludeFromCandidateRecursive4'


class CandidateArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    
    

class FindManyCandidateArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive1'


class FindManyCandidateArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive2'


class FindManyCandidateArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive3'


class FindManyCandidateArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive4'


class FindManyCandidateArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    
    

class SearchIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    user: Union[bool, 'UserArgsFromCandidateRecursive1']
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive1']


class SearchIncludeFromCandidateRecursive1(TypedDict, total=False):
    """Relational arguments for Candidate"""
    user: Union[bool, 'UserArgsFromCandidateRecursive2']
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive2']


class SearchIncludeFromCandidateRecursive2(TypedDict, total=False):
    """Relational arguments for Candidate"""
    user: Union[bool, 'UserArgsFromCandidateRecursive3']
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive3']


class SearchIncludeFromCandidateRecursive3(TypedDict, total=False):
    """Relational arguments for Candidate"""
    user: Union[bool, 'UserArgsFromCandidateRecursive4']
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive4']


class SearchIncludeFromCandidateRecursive4(TypedDict, total=False):
    """Relational arguments for Candidate"""

    

class SearchArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'SearchIncludeFromSearchRecursive1'


class SearchArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'SearchIncludeFromSearchRecursive2'


class SearchArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'SearchIncludeFromSearchRecursive3'


class SearchArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'SearchIncludeFromSearchRecursive4'


class SearchArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    
    

class FindManySearchArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive1'


class FindManySearchArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive2'


class FindManySearchArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive3'


class FindManySearchArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive4'


class FindManySearchArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    
    

class JobIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive1']
    user: Union[bool, 'UserArgsFromCandidateRecursive1']
    company: Union[bool, 'CompanyArgsFromCandidateRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive1']


class JobIncludeFromCandidateRecursive1(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive2']
    user: Union[bool, 'UserArgsFromCandidateRecursive2']
    company: Union[bool, 'CompanyArgsFromCandidateRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive2']


class JobIncludeFromCandidateRecursive2(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive3']
    user: Union[bool, 'UserArgsFromCandidateRecursive3']
    company: Union[bool, 'CompanyArgsFromCandidateRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive3']


class JobIncludeFromCandidateRecursive3(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive4']
    user: Union[bool, 'UserArgsFromCandidateRecursive4']
    company: Union[bool, 'CompanyArgsFromCandidateRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']
    createdBy: Union[bool, 'UserArgsFromCandidateRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCandidateRecursive4']


class JobIncludeFromCandidateRecursive4(TypedDict, total=False):
    """Relational arguments for Candidate"""

    

class JobArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'JobIncludeFromJobRecursive1'


class JobArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'JobIncludeFromJobRecursive2'


class JobArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'JobIncludeFromJobRecursive3'


class JobArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'JobIncludeFromJobRecursive4'


class JobArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    
    

class FindManyJobArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive1'


class FindManyJobArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive2'


class FindManyJobArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive3'


class FindManyJobArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive4'


class FindManyJobArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    
    

class CompanyIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive1']


class CompanyIncludeFromCandidateRecursive1(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive2']


class CompanyIncludeFromCandidateRecursive2(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive3']


class CompanyIncludeFromCandidateRecursive3(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidateRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCandidateRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidateRecursive4']


class CompanyIncludeFromCandidateRecursive4(TypedDict, total=False):
    """Relational arguments for Candidate"""

    

class CompanyArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CompanyIncludeFromCompanyRecursive1'


class CompanyArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CompanyIncludeFromCompanyRecursive2'


class CompanyArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CompanyIncludeFromCompanyRecursive3'


class CompanyArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CompanyIncludeFromCompanyRecursive4'


class CompanyArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    
    

class FindManyCompanyArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive1'


class FindManyCompanyArgsFromCandidateRecursive1(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive2'


class FindManyCompanyArgsFromCandidateRecursive2(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive3'


class FindManyCompanyArgsFromCandidateRecursive3(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive4'


class FindManyCompanyArgsFromCandidateRecursive4(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    


FindManyCandidateArgs = FindManyCandidateArgsFromCandidate
FindFirstCandidateArgs = FindManyCandidateArgsFromCandidate


    

class CandidateWhereInput(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    linkedin: Union[None, _str, 'types.StringFilter']
    github: Union[None, _str, 'types.StringFilter']
    website: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[None, _str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    profile: Union[None, 'fields.Json', 'types.JsonFilter']
    notes: Union[None, _str, 'types.StringFilter']
    lastTouched: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tenantId: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    lastTouchedById: Union[None, _str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    user: 'UserRelationFilter'
    lastTouchedBy: 'UserRelationFilter'
    searches: 'SearchListRelationFilter'
    companies: 'CompanyListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CandidateWhereInputRecursive1', List['CandidateWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CandidateWhereInputRecursive1']
    OR: List['CandidateWhereInputRecursive1']
    NOT: List['CandidateWhereInputRecursive1']


class CandidateWhereInputRecursive1(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    linkedin: Union[None, _str, 'types.StringFilter']
    github: Union[None, _str, 'types.StringFilter']
    website: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[None, _str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    profile: Union[None, 'fields.Json', 'types.JsonFilter']
    notes: Union[None, _str, 'types.StringFilter']
    lastTouched: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tenantId: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    lastTouchedById: Union[None, _str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    user: 'UserRelationFilter'
    lastTouchedBy: 'UserRelationFilter'
    searches: 'SearchListRelationFilter'
    companies: 'CompanyListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CandidateWhereInputRecursive2', List['CandidateWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CandidateWhereInputRecursive2']
    OR: List['CandidateWhereInputRecursive2']
    NOT: List['CandidateWhereInputRecursive2']


class CandidateWhereInputRecursive2(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    linkedin: Union[None, _str, 'types.StringFilter']
    github: Union[None, _str, 'types.StringFilter']
    website: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[None, _str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    profile: Union[None, 'fields.Json', 'types.JsonFilter']
    notes: Union[None, _str, 'types.StringFilter']
    lastTouched: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tenantId: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    lastTouchedById: Union[None, _str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    user: 'UserRelationFilter'
    lastTouchedBy: 'UserRelationFilter'
    searches: 'SearchListRelationFilter'
    companies: 'CompanyListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CandidateWhereInputRecursive3', List['CandidateWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CandidateWhereInputRecursive3']
    OR: List['CandidateWhereInputRecursive3']
    NOT: List['CandidateWhereInputRecursive3']


class CandidateWhereInputRecursive3(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    linkedin: Union[None, _str, 'types.StringFilter']
    github: Union[None, _str, 'types.StringFilter']
    website: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[None, _str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    profile: Union[None, 'fields.Json', 'types.JsonFilter']
    notes: Union[None, _str, 'types.StringFilter']
    lastTouched: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tenantId: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    lastTouchedById: Union[None, _str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    user: 'UserRelationFilter'
    lastTouchedBy: 'UserRelationFilter'
    searches: 'SearchListRelationFilter'
    companies: 'CompanyListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CandidateWhereInputRecursive4', List['CandidateWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CandidateWhereInputRecursive4']
    OR: List['CandidateWhereInputRecursive4']
    NOT: List['CandidateWhereInputRecursive4']


class CandidateWhereInputRecursive4(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    linkedin: Union[None, _str, 'types.StringFilter']
    github: Union[None, _str, 'types.StringFilter']
    website: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[None, _str, 'types.StringFilter']
    source: Union[None, _str, 'types.StringFilter']
    profile: Union[None, 'fields.Json', 'types.JsonFilter']
    notes: Union[None, _str, 'types.StringFilter']
    lastTouched: Union[None, datetime.datetime, 'types.DateTimeFilter']
    tenantId: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    lastTouchedById: Union[None, _str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    user: 'UserRelationFilter'
    lastTouchedBy: 'UserRelationFilter'
    searches: 'SearchListRelationFilter'
    companies: 'CompanyListRelationFilter'
    jobs: 'JobListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']



# aggregate Candidate types


    

class CandidateScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    linkedin: Union[_str, 'types.StringWithAggregatesFilter']
    github: Union[_str, 'types.StringWithAggregatesFilter']
    website: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    profile: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouched: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouchedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CandidateScalarWhereWithAggregatesInputRecursive1']
    OR: List['CandidateScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CandidateScalarWhereWithAggregatesInputRecursive1']


class CandidateScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    linkedin: Union[_str, 'types.StringWithAggregatesFilter']
    github: Union[_str, 'types.StringWithAggregatesFilter']
    website: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    profile: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouched: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouchedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CandidateScalarWhereWithAggregatesInputRecursive2']
    OR: List['CandidateScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CandidateScalarWhereWithAggregatesInputRecursive2']


class CandidateScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    linkedin: Union[_str, 'types.StringWithAggregatesFilter']
    github: Union[_str, 'types.StringWithAggregatesFilter']
    website: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    profile: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouched: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouchedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CandidateScalarWhereWithAggregatesInputRecursive3']
    OR: List['CandidateScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CandidateScalarWhereWithAggregatesInputRecursive3']


class CandidateScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    linkedin: Union[_str, 'types.StringWithAggregatesFilter']
    github: Union[_str, 'types.StringWithAggregatesFilter']
    website: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    profile: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouched: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouchedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CandidateScalarWhereWithAggregatesInputRecursive4']
    OR: List['CandidateScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CandidateScalarWhereWithAggregatesInputRecursive4']


class CandidateScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    linkedin: Union[_str, 'types.StringWithAggregatesFilter']
    github: Union[_str, 'types.StringWithAggregatesFilter']
    website: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']
    profile: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouched: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    lastTouchedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']



class CandidateGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    email: _str
    linkedin: _str
    github: _str
    website: _str
    phone: _str
    location: _str
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: _str
    source: _str
    profile: 'fields.Json'
    notes: _str
    lastTouched: datetime.datetime
    tenantId: _str
    userId: _str
    lastTouchedById: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool
    _sum: 'CandidateSumAggregateOutput'
    _avg: 'CandidateAvgAggregateOutput'
    _min: 'CandidateMinAggregateOutput'
    _max: 'CandidateMaxAggregateOutput'
    _count: 'CandidateCountAggregateOutput'


class CandidateAvgAggregateOutput(TypedDict, total=False):
    """Candidate output for aggregating averages"""


class CandidateSumAggregateOutput(TypedDict, total=False):
    """Candidate output for aggregating sums"""


class CandidateScalarAggregateOutput(TypedDict, total=False):
    """Candidate output including scalar fields"""
    id: _str
    name: _str
    email: _str
    linkedin: _str
    github: _str
    website: _str
    phone: _str
    location: _str
    status: 'enums.CandidateStatus'
    interest: 'enums.CandidateInterest'
    careerLevel: 'enums.CandidateCareerLevel'
    resume: _str
    source: _str
    profile: 'fields.Json'
    notes: _str
    lastTouched: datetime.datetime
    tenantId: _str
    userId: _str
    lastTouchedById: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool


CandidateMinAggregateOutput = CandidateScalarAggregateOutput
CandidateMaxAggregateOutput = CandidateScalarAggregateOutput


class CandidateMaxAggregateInput(TypedDict, total=False):
    """Candidate input for aggregating by max"""
    id: bool
    name: bool
    email: bool
    linkedin: bool
    github: bool
    website: bool
    phone: bool
    location: bool
    status: bool
    interest: bool
    careerLevel: bool
    resume: bool
    source: bool
    profile: bool
    notes: bool
    lastTouched: bool
    tenantId: bool
    userId: bool
    lastTouchedById: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class CandidateMinAggregateInput(TypedDict, total=False):
    """Candidate input for aggregating by min"""
    id: bool
    name: bool
    email: bool
    linkedin: bool
    github: bool
    website: bool
    phone: bool
    location: bool
    status: bool
    interest: bool
    careerLevel: bool
    resume: bool
    source: bool
    profile: bool
    notes: bool
    lastTouched: bool
    tenantId: bool
    userId: bool
    lastTouchedById: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class CandidateNumberAggregateInput(TypedDict, total=False):
    """Candidate input for aggregating numbers"""


CandidateAvgAggregateInput = CandidateNumberAggregateInput
CandidateSumAggregateInput = CandidateNumberAggregateInput


CandidateCountAggregateInput = TypedDict(
    'CandidateCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'email': bool,
        'linkedin': bool,
        'github': bool,
        'website': bool,
        'phone': bool,
        'location': bool,
        'status': bool,
        'interest': bool,
        'careerLevel': bool,
        'resume': bool,
        'source': bool,
        'profile': bool,
        'notes': bool,
        'lastTouched': bool,
        'tenantId': bool,
        'userId': bool,
        'lastTouchedById': bool,
        'createdById': bool,
        'updatedById': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deletedAt': bool,
        'deleted': bool,
        '_all': bool,
    },
    total=False,
)

CandidateCountAggregateOutput = TypedDict(
    'CandidateCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'email': int,
        'linkedin': int,
        'github': int,
        'website': int,
        'phone': int,
        'location': int,
        'status': int,
        'interest': int,
        'careerLevel': int,
        'resume': int,
        'source': int,
        'profile': int,
        'notes': int,
        'lastTouched': int,
        'tenantId': int,
        'userId': int,
        'lastTouchedById': int,
        'createdById': int,
        'updatedById': int,
        'createdAt': int,
        'updatedAt': int,
        'deletedAt': int,
        'deleted': int,
        '_all': int,
    },
    total=False,
)


CandidateKeys = Literal[
    'id',
    'name',
    'email',
    'linkedin',
    'github',
    'website',
    'phone',
    'location',
    'status',
    'interest',
    'careerLevel',
    'resume',
    'source',
    'profile',
    'notes',
    'lastTouched',
    'tenantId',
    'userId',
    'lastTouchedById',
    'tenant',
    'user',
    'lastTouchedBy',
    'searches',
    'companies',
    'jobs',
    'createdById',
    'updatedById',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
CandidateScalarFieldKeys = Literal[
    'id',
    'name',
    'email',
    'linkedin',
    'github',
    'website',
    'phone',
    'location',
    'status',
    'interest',
    'careerLevel',
    'resume',
    'source',
    'profile',
    'notes',
    'lastTouched',
    'tenantId',
    'userId',
    'lastTouchedById',
    'createdById',
    'updatedById',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
CandidateScalarFieldKeysT = TypeVar('CandidateScalarFieldKeysT', bound=CandidateScalarFieldKeys)

CandidateRelationalFieldKeys = Literal[
        'tenant',
        'user',
        'lastTouchedBy',
        'searches',
        'companies',
        'jobs',
        'createdBy',
        'updatedBy',
    ]

# Search types

class SearchOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Search create method"""
    id: _str
    userId: _str
    tenantId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    candidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    updatedBy: 'UserCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class SearchCreateInput(SearchOptionalCreateInput):
    """Required arguments to the Search create method"""
    title: _str
    filters: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SearchOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Search create method, without relations"""
    id: _str
    userId: _str
    tenantId: _str
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class SearchCreateWithoutRelationsInput(SearchOptionalCreateWithoutRelationsInput):
    """Required arguments to the Search create method, without relations"""
    title: _str
    filters: 'fields.Json'

class SearchConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'SearchCreateWithoutRelationsInput'
    where: 'SearchWhereUniqueInput'

class SearchCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SearchCreateWithoutRelationsInput'
    connect: 'SearchWhereUniqueInput'
    connect_or_create: 'SearchConnectOrCreateWithoutRelationsInput'


class SearchCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SearchCreateWithoutRelationsInput', List['SearchCreateWithoutRelationsInput']]
    connect: Union['SearchWhereUniqueInput', List['SearchWhereUniqueInput']]
    connect_or_create: Union['SearchConnectOrCreateWithoutRelationsInput', List['SearchConnectOrCreateWithoutRelationsInput']]

_SearchWhereUnique_id_Input = TypedDict(
    '_SearchWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

SearchWhereUniqueInput = _SearchWhereUnique_id_Input


class SearchUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    title: _str
    filters: 'fields.Json'
    user: 'UserUpdateOneWithoutRelationsInput'
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    candidates: 'CandidateUpdateManyWithoutRelationsInput'
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    updatedBy: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class SearchUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    title: _str
    filters: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class SearchUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SearchCreateWithoutRelationsInput']
    connect: List['SearchWhereUniqueInput']
    connect_or_create: List['SearchConnectOrCreateWithoutRelationsInput']
    set: List['SearchWhereUniqueInput']
    disconnect: List['SearchWhereUniqueInput']
    delete: List['SearchWhereUniqueInput']

    # TODO
    # update: List['SearchUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SearchUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SearchScalarWhereInput']
    # upsert: List['SearchUpserteWithWhereUniqueWithoutRelationsInput']


class SearchUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SearchCreateWithoutRelationsInput'
    connect: 'SearchWhereUniqueInput'
    connect_or_create: 'SearchConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SearchUpdateInput'
    # upsert: 'SearchUpsertWithoutRelationsInput'


class SearchUpsertInput(TypedDict):
    create: 'SearchCreateInput'
    update: 'SearchUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Search_id_OrderByInput = TypedDict(
    '_Search_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Search_title_OrderByInput = TypedDict(
    '_Search_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Search_filters_OrderByInput = TypedDict(
    '_Search_filters_OrderByInput',
    {
        'filters': 'SortOrder',
    },
    total=True
)

_Search_userId_OrderByInput = TypedDict(
    '_Search_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Search_tenantId_OrderByInput = TypedDict(
    '_Search_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Search_createdById_OrderByInput = TypedDict(
    '_Search_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_Search_updatedById_OrderByInput = TypedDict(
    '_Search_updatedById_OrderByInput',
    {
        'updatedById': 'SortOrder',
    },
    total=True
)

_Search_createdAt_OrderByInput = TypedDict(
    '_Search_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Search_updatedAt_OrderByInput = TypedDict(
    '_Search_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Search_deletedAt_OrderByInput = TypedDict(
    '_Search_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Search_deleted_OrderByInput = TypedDict(
    '_Search_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Search_RelevanceInner = TypedDict(
    '_Search_RelevanceInner',
    {
        'fields': 'List[SearchScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Search_RelevanceOrderByInput = TypedDict(
    '_Search_RelevanceOrderByInput',
    {
        '_relevance': '_Search_RelevanceInner',
    },
    total=True
)

SearchOrderByInput = Union[
    '_Search_id_OrderByInput',
    '_Search_title_OrderByInput',
    '_Search_filters_OrderByInput',
    '_Search_userId_OrderByInput',
    '_Search_tenantId_OrderByInput',
    '_Search_createdById_OrderByInput',
    '_Search_updatedById_OrderByInput',
    '_Search_createdAt_OrderByInput',
    '_Search_updatedAt_OrderByInput',
    '_Search_deletedAt_OrderByInput',
    '_Search_deleted_OrderByInput',
    '_Search_RelevanceOrderByInput',
]



# recursive Search types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SearchRelationFilter = TypedDict(
    'SearchRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SearchListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SearchInclude(TypedDict, total=False):
    """Search relational arguments"""
    user: Union[bool, 'UserArgsFromSearch']
    tenant: Union[bool, 'TenantArgsFromSearch']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearch']
    createdBy: Union[bool, 'UserArgsFromSearch']
    updatedBy: Union[bool, 'UserArgsFromSearch']


    

class TenantIncludeFromSearch(TypedDict, total=False):
    """Relational arguments for Search"""
    users: Union[bool, 'FindManyUserArgsFromSearchRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive1']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive1']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive1']


class TenantIncludeFromSearchRecursive1(TypedDict, total=False):
    """Relational arguments for Search"""
    users: Union[bool, 'FindManyUserArgsFromSearchRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive2']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive2']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive2']


class TenantIncludeFromSearchRecursive2(TypedDict, total=False):
    """Relational arguments for Search"""
    users: Union[bool, 'FindManyUserArgsFromSearchRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive3']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive3']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive3']


class TenantIncludeFromSearchRecursive3(TypedDict, total=False):
    """Relational arguments for Search"""
    users: Union[bool, 'FindManyUserArgsFromSearchRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive4']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive4']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive4']


class TenantIncludeFromSearchRecursive4(TypedDict, total=False):
    """Relational arguments for Search"""

    

class TenantArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    include: 'TenantIncludeFromTenantRecursive1'


class TenantArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    include: 'TenantIncludeFromTenantRecursive2'


class TenantArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    include: 'TenantIncludeFromTenantRecursive3'


class TenantArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    include: 'TenantIncludeFromTenantRecursive4'


class TenantArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    
    

class FindManyTenantArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive1'


class FindManyTenantArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive2'


class FindManyTenantArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive3'


class FindManyTenantArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive4'


class FindManyTenantArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    
    

class UserIncludeFromSearch(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive1']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive1']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive1']
    createdTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive1']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive1']
    createdUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive1']
    updatedUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive1']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']
    createdSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive1']
    updatedSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive1']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']
    createdJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive1']
    updatedJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive1']


class UserIncludeFromSearchRecursive1(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive2']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive2']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive2']
    createdTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive2']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive2']
    createdUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive2']
    updatedUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive2']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']
    createdSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive2']
    updatedSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive2']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']
    createdJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive2']
    updatedJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive2']


class UserIncludeFromSearchRecursive2(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive3']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive3']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive3']
    createdTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive3']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive3']
    createdUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive3']
    updatedUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive3']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']
    createdSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive3']
    updatedSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive3']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']
    createdJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive3']
    updatedJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive3']


class UserIncludeFromSearchRecursive3(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive4']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive4']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive4']
    createdTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive4']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromSearchRecursive4']
    createdUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive4']
    updatedUsers: Union[bool, 'FindManyUserArgsFromSearchRecursive4']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']
    createdSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive4']
    updatedSearches: Union[bool, 'FindManySearchArgsFromSearchRecursive4']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']
    createdJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive4']
    updatedJobs: Union[bool, 'FindManyJobArgsFromSearchRecursive4']


class UserIncludeFromSearchRecursive4(TypedDict, total=False):
    """Relational arguments for Search"""

    

class UserArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    
    

class FindManyUserArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class CandidateIncludeFromSearch(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive1']
    user: Union[bool, 'UserArgsFromSearchRecursive1']
    lastTouchedBy: Union[bool, 'UserArgsFromSearchRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive1']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive1']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive1']


class CandidateIncludeFromSearchRecursive1(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive2']
    user: Union[bool, 'UserArgsFromSearchRecursive2']
    lastTouchedBy: Union[bool, 'UserArgsFromSearchRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive2']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive2']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive2']


class CandidateIncludeFromSearchRecursive2(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive3']
    user: Union[bool, 'UserArgsFromSearchRecursive3']
    lastTouchedBy: Union[bool, 'UserArgsFromSearchRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive3']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive3']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive3']


class CandidateIncludeFromSearchRecursive3(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive4']
    user: Union[bool, 'UserArgsFromSearchRecursive4']
    lastTouchedBy: Union[bool, 'UserArgsFromSearchRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromSearchRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromSearchRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive4']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive4']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive4']


class CandidateIncludeFromSearchRecursive4(TypedDict, total=False):
    """Relational arguments for Search"""

    

class CandidateArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CandidateIncludeFromCandidateRecursive1'


class CandidateArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CandidateIncludeFromCandidateRecursive2'


class CandidateArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CandidateIncludeFromCandidateRecursive3'


class CandidateArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CandidateIncludeFromCandidateRecursive4'


class CandidateArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    
    

class FindManyCandidateArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive1'


class FindManyCandidateArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive2'


class FindManyCandidateArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive3'


class FindManyCandidateArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive4'


class FindManyCandidateArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    
    

class SearchIncludeFromSearch(TypedDict, total=False):
    """Relational arguments for Search"""
    user: Union[bool, 'UserArgsFromSearchRecursive1']
    tenant: Union[bool, 'TenantArgsFromSearchRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive1']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive1']


class SearchIncludeFromSearchRecursive1(TypedDict, total=False):
    """Relational arguments for Search"""
    user: Union[bool, 'UserArgsFromSearchRecursive2']
    tenant: Union[bool, 'TenantArgsFromSearchRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive2']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive2']


class SearchIncludeFromSearchRecursive2(TypedDict, total=False):
    """Relational arguments for Search"""
    user: Union[bool, 'UserArgsFromSearchRecursive3']
    tenant: Union[bool, 'TenantArgsFromSearchRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive3']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive3']


class SearchIncludeFromSearchRecursive3(TypedDict, total=False):
    """Relational arguments for Search"""
    user: Union[bool, 'UserArgsFromSearchRecursive4']
    tenant: Union[bool, 'TenantArgsFromSearchRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive4']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive4']


class SearchIncludeFromSearchRecursive4(TypedDict, total=False):
    """Relational arguments for Search"""

    

class SearchArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    include: 'SearchIncludeFromSearchRecursive1'


class SearchArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    include: 'SearchIncludeFromSearchRecursive2'


class SearchArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    include: 'SearchIncludeFromSearchRecursive3'


class SearchArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    include: 'SearchIncludeFromSearchRecursive4'


class SearchArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    
    

class FindManySearchArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive1'


class FindManySearchArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive2'


class FindManySearchArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive3'


class FindManySearchArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive4'


class FindManySearchArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    
    

class JobIncludeFromSearch(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive1']
    user: Union[bool, 'UserArgsFromSearchRecursive1']
    company: Union[bool, 'CompanyArgsFromSearchRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive1']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive1']


class JobIncludeFromSearchRecursive1(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive2']
    user: Union[bool, 'UserArgsFromSearchRecursive2']
    company: Union[bool, 'CompanyArgsFromSearchRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive2']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive2']


class JobIncludeFromSearchRecursive2(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive3']
    user: Union[bool, 'UserArgsFromSearchRecursive3']
    company: Union[bool, 'CompanyArgsFromSearchRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive3']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive3']


class JobIncludeFromSearchRecursive3(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive4']
    user: Union[bool, 'UserArgsFromSearchRecursive4']
    company: Union[bool, 'CompanyArgsFromSearchRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']
    createdBy: Union[bool, 'UserArgsFromSearchRecursive4']
    updatedBy: Union[bool, 'UserArgsFromSearchRecursive4']


class JobIncludeFromSearchRecursive4(TypedDict, total=False):
    """Relational arguments for Search"""

    

class JobArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    include: 'JobIncludeFromJobRecursive1'


class JobArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    include: 'JobIncludeFromJobRecursive2'


class JobArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    include: 'JobIncludeFromJobRecursive3'


class JobArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    include: 'JobIncludeFromJobRecursive4'


class JobArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    
    

class FindManyJobArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive1'


class FindManyJobArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive2'


class FindManyJobArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive3'


class FindManyJobArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive4'


class FindManyJobArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    
    

class CompanyIncludeFromSearch(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive1']


class CompanyIncludeFromSearchRecursive1(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive2']


class CompanyIncludeFromSearchRecursive2(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive3']


class CompanyIncludeFromSearchRecursive3(TypedDict, total=False):
    """Relational arguments for Search"""
    tenant: Union[bool, 'TenantArgsFromSearchRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromSearchRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromSearchRecursive4']


class CompanyIncludeFromSearchRecursive4(TypedDict, total=False):
    """Relational arguments for Search"""

    

class CompanyArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CompanyIncludeFromCompanyRecursive1'


class CompanyArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CompanyIncludeFromCompanyRecursive2'


class CompanyArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CompanyIncludeFromCompanyRecursive3'


class CompanyArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    include: 'CompanyIncludeFromCompanyRecursive4'


class CompanyArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    
    

class FindManyCompanyArgsFromSearch(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive1'


class FindManyCompanyArgsFromSearchRecursive1(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive2'


class FindManyCompanyArgsFromSearchRecursive2(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive3'


class FindManyCompanyArgsFromSearchRecursive3(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive4'


class FindManyCompanyArgsFromSearchRecursive4(TypedDict, total=False):
    """Arguments for Search"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    


FindManySearchArgs = FindManySearchArgsFromSearch
FindFirstSearchArgs = FindManySearchArgsFromSearch


    

class SearchWhereInput(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    filters: Union['fields.Json', 'types.JsonFilter']
    userId: Union[_str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    tenant: 'TenantRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['SearchWhereInputRecursive1', List['SearchWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SearchWhereInputRecursive1']
    OR: List['SearchWhereInputRecursive1']
    NOT: List['SearchWhereInputRecursive1']


class SearchWhereInputRecursive1(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    filters: Union['fields.Json', 'types.JsonFilter']
    userId: Union[_str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    tenant: 'TenantRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['SearchWhereInputRecursive2', List['SearchWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SearchWhereInputRecursive2']
    OR: List['SearchWhereInputRecursive2']
    NOT: List['SearchWhereInputRecursive2']


class SearchWhereInputRecursive2(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    filters: Union['fields.Json', 'types.JsonFilter']
    userId: Union[_str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    tenant: 'TenantRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['SearchWhereInputRecursive3', List['SearchWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SearchWhereInputRecursive3']
    OR: List['SearchWhereInputRecursive3']
    NOT: List['SearchWhereInputRecursive3']


class SearchWhereInputRecursive3(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    filters: Union['fields.Json', 'types.JsonFilter']
    userId: Union[_str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    tenant: 'TenantRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['SearchWhereInputRecursive4', List['SearchWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SearchWhereInputRecursive4']
    OR: List['SearchWhereInputRecursive4']
    NOT: List['SearchWhereInputRecursive4']


class SearchWhereInputRecursive4(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    filters: Union['fields.Json', 'types.JsonFilter']
    userId: Union[_str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    tenant: 'TenantRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']



# aggregate Search types


    

class SearchScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    filters: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['SearchScalarWhereWithAggregatesInputRecursive1']
    OR: List['SearchScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SearchScalarWhereWithAggregatesInputRecursive1']


class SearchScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    filters: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['SearchScalarWhereWithAggregatesInputRecursive2']
    OR: List['SearchScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SearchScalarWhereWithAggregatesInputRecursive2']


class SearchScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    filters: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['SearchScalarWhereWithAggregatesInputRecursive3']
    OR: List['SearchScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SearchScalarWhereWithAggregatesInputRecursive3']


class SearchScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    filters: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['SearchScalarWhereWithAggregatesInputRecursive4']
    OR: List['SearchScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SearchScalarWhereWithAggregatesInputRecursive4']


class SearchScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Search arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    filters: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']



class SearchGroupByOutput(TypedDict, total=False):
    id: _str
    title: _str
    filters: 'fields.Json'
    userId: _str
    tenantId: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool
    _sum: 'SearchSumAggregateOutput'
    _avg: 'SearchAvgAggregateOutput'
    _min: 'SearchMinAggregateOutput'
    _max: 'SearchMaxAggregateOutput'
    _count: 'SearchCountAggregateOutput'


class SearchAvgAggregateOutput(TypedDict, total=False):
    """Search output for aggregating averages"""


class SearchSumAggregateOutput(TypedDict, total=False):
    """Search output for aggregating sums"""


class SearchScalarAggregateOutput(TypedDict, total=False):
    """Search output including scalar fields"""
    id: _str
    title: _str
    filters: 'fields.Json'
    userId: _str
    tenantId: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool


SearchMinAggregateOutput = SearchScalarAggregateOutput
SearchMaxAggregateOutput = SearchScalarAggregateOutput


class SearchMaxAggregateInput(TypedDict, total=False):
    """Search input for aggregating by max"""
    id: bool
    title: bool
    filters: bool
    userId: bool
    tenantId: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class SearchMinAggregateInput(TypedDict, total=False):
    """Search input for aggregating by min"""
    id: bool
    title: bool
    filters: bool
    userId: bool
    tenantId: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class SearchNumberAggregateInput(TypedDict, total=False):
    """Search input for aggregating numbers"""


SearchAvgAggregateInput = SearchNumberAggregateInput
SearchSumAggregateInput = SearchNumberAggregateInput


SearchCountAggregateInput = TypedDict(
    'SearchCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'filters': bool,
        'userId': bool,
        'tenantId': bool,
        'createdById': bool,
        'updatedById': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deletedAt': bool,
        'deleted': bool,
        '_all': bool,
    },
    total=False,
)

SearchCountAggregateOutput = TypedDict(
    'SearchCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'filters': int,
        'userId': int,
        'tenantId': int,
        'createdById': int,
        'updatedById': int,
        'createdAt': int,
        'updatedAt': int,
        'deletedAt': int,
        'deleted': int,
        '_all': int,
    },
    total=False,
)


SearchKeys = Literal[
    'id',
    'title',
    'filters',
    'userId',
    'tenantId',
    'user',
    'tenant',
    'candidates',
    'createdById',
    'updatedById',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
SearchScalarFieldKeys = Literal[
    'id',
    'title',
    'filters',
    'userId',
    'tenantId',
    'createdById',
    'updatedById',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
SearchScalarFieldKeysT = TypeVar('SearchScalarFieldKeysT', bound=SearchScalarFieldKeys)

SearchRelationalFieldKeys = Literal[
        'user',
        'tenant',
        'candidates',
        'createdBy',
        'updatedBy',
    ]

# Job types

class JobOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Job create method"""
    id: _str
    description: Optional[_str]
    location: Optional[_str]
    salaryMin: Optional[_int]
    salaryMax: Optional[_int]
    employmentType: Optional[_str]
    status: 'enums.JobStatus'
    requirements: Optional[_str]
    responsibilities: Optional[_str]
    benefits: Optional[_str]
    industry: Optional['enums.Industry']
    tenantId: _str
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    companyId: _str
    company: 'CompanyCreateNestedWithoutRelationsInput'
    candidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    updatedBy: 'UserCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class JobCreateInput(JobOptionalCreateInput):
    """Required arguments to the Job create method"""
    title: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class JobOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Job create method, without relations"""
    id: _str
    description: Optional[_str]
    location: Optional[_str]
    salaryMin: Optional[_int]
    salaryMax: Optional[_int]
    employmentType: Optional[_str]
    status: 'enums.JobStatus'
    requirements: Optional[_str]
    responsibilities: Optional[_str]
    benefits: Optional[_str]
    industry: Optional['enums.Industry']
    tenantId: _str
    userId: _str
    companyId: _str
    createdById: Optional[_str]
    updatedById: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class JobCreateWithoutRelationsInput(JobOptionalCreateWithoutRelationsInput):
    """Required arguments to the Job create method, without relations"""
    title: _str

class JobConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'JobCreateWithoutRelationsInput'
    where: 'JobWhereUniqueInput'

class JobCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'JobCreateWithoutRelationsInput'
    connect: 'JobWhereUniqueInput'
    connect_or_create: 'JobConnectOrCreateWithoutRelationsInput'


class JobCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['JobCreateWithoutRelationsInput', List['JobCreateWithoutRelationsInput']]
    connect: Union['JobWhereUniqueInput', List['JobWhereUniqueInput']]
    connect_or_create: Union['JobConnectOrCreateWithoutRelationsInput', List['JobConnectOrCreateWithoutRelationsInput']]

_JobWhereUnique_id_Input = TypedDict(
    '_JobWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_JobCompoundunique_job_title_tenantKeyInner = TypedDict(
    '_JobCompoundunique_job_title_tenantKeyInner',
    {
        'tenantId': '_str',
        'title': '_str',
        'deletedAt': 'datetime.datetime',
    },
    total=True
)

_JobCompoundunique_job_title_tenantKey = TypedDict(
    '_JobCompoundunique_job_title_tenantKey',
    {
        'unique_job_title_tenant': '_JobCompoundunique_job_title_tenantKeyInner',
    },
    total=True
)

JobWhereUniqueInput = Union[
    '_JobWhereUnique_id_Input',
    '_JobCompoundunique_job_title_tenantKey',
]


class JobUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    title: _str
    description: Optional[_str]
    location: Optional[_str]
    salaryMin: Optional[Union[AtomicIntInput, _int]]
    salaryMax: Optional[Union[AtomicIntInput, _int]]
    employmentType: Optional[_str]
    status: 'enums.JobStatus'
    requirements: Optional[_str]
    responsibilities: Optional[_str]
    benefits: Optional[_str]
    industry: Optional['enums.Industry']
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    user: 'UserUpdateOneWithoutRelationsInput'
    company: 'CompanyUpdateOneWithoutRelationsInput'
    candidates: 'CandidateUpdateManyWithoutRelationsInput'
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    updatedBy: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class JobUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    title: _str
    description: Optional[_str]
    location: Optional[_str]
    salaryMin: Optional[Union[AtomicIntInput, _int]]
    salaryMax: Optional[Union[AtomicIntInput, _int]]
    employmentType: Optional[_str]
    status: 'enums.JobStatus'
    requirements: Optional[_str]
    responsibilities: Optional[_str]
    benefits: Optional[_str]
    industry: Optional['enums.Industry']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class JobUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['JobCreateWithoutRelationsInput']
    connect: List['JobWhereUniqueInput']
    connect_or_create: List['JobConnectOrCreateWithoutRelationsInput']
    set: List['JobWhereUniqueInput']
    disconnect: List['JobWhereUniqueInput']
    delete: List['JobWhereUniqueInput']

    # TODO
    # update: List['JobUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['JobUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['JobScalarWhereInput']
    # upsert: List['JobUpserteWithWhereUniqueWithoutRelationsInput']


class JobUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'JobCreateWithoutRelationsInput'
    connect: 'JobWhereUniqueInput'
    connect_or_create: 'JobConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'JobUpdateInput'
    # upsert: 'JobUpsertWithoutRelationsInput'


class JobUpsertInput(TypedDict):
    create: 'JobCreateInput'
    update: 'JobUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Job_id_OrderByInput = TypedDict(
    '_Job_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Job_title_OrderByInput = TypedDict(
    '_Job_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Job_description_OrderByInput = TypedDict(
    '_Job_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Job_location_OrderByInput = TypedDict(
    '_Job_location_OrderByInput',
    {
        'location': 'SortOrder',
    },
    total=True
)

_Job_salaryMin_OrderByInput = TypedDict(
    '_Job_salaryMin_OrderByInput',
    {
        'salaryMin': 'SortOrder',
    },
    total=True
)

_Job_salaryMax_OrderByInput = TypedDict(
    '_Job_salaryMax_OrderByInput',
    {
        'salaryMax': 'SortOrder',
    },
    total=True
)

_Job_employmentType_OrderByInput = TypedDict(
    '_Job_employmentType_OrderByInput',
    {
        'employmentType': 'SortOrder',
    },
    total=True
)

_Job_status_OrderByInput = TypedDict(
    '_Job_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Job_requirements_OrderByInput = TypedDict(
    '_Job_requirements_OrderByInput',
    {
        'requirements': 'SortOrder',
    },
    total=True
)

_Job_responsibilities_OrderByInput = TypedDict(
    '_Job_responsibilities_OrderByInput',
    {
        'responsibilities': 'SortOrder',
    },
    total=True
)

_Job_benefits_OrderByInput = TypedDict(
    '_Job_benefits_OrderByInput',
    {
        'benefits': 'SortOrder',
    },
    total=True
)

_Job_industry_OrderByInput = TypedDict(
    '_Job_industry_OrderByInput',
    {
        'industry': 'SortOrder',
    },
    total=True
)

_Job_tenantId_OrderByInput = TypedDict(
    '_Job_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Job_userId_OrderByInput = TypedDict(
    '_Job_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Job_companyId_OrderByInput = TypedDict(
    '_Job_companyId_OrderByInput',
    {
        'companyId': 'SortOrder',
    },
    total=True
)

_Job_createdById_OrderByInput = TypedDict(
    '_Job_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_Job_updatedById_OrderByInput = TypedDict(
    '_Job_updatedById_OrderByInput',
    {
        'updatedById': 'SortOrder',
    },
    total=True
)

_Job_createdAt_OrderByInput = TypedDict(
    '_Job_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Job_updatedAt_OrderByInput = TypedDict(
    '_Job_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Job_deletedAt_OrderByInput = TypedDict(
    '_Job_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Job_deleted_OrderByInput = TypedDict(
    '_Job_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Job_RelevanceInner = TypedDict(
    '_Job_RelevanceInner',
    {
        'fields': 'List[JobScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Job_RelevanceOrderByInput = TypedDict(
    '_Job_RelevanceOrderByInput',
    {
        '_relevance': '_Job_RelevanceInner',
    },
    total=True
)

JobOrderByInput = Union[
    '_Job_id_OrderByInput',
    '_Job_title_OrderByInput',
    '_Job_description_OrderByInput',
    '_Job_location_OrderByInput',
    '_Job_salaryMin_OrderByInput',
    '_Job_salaryMax_OrderByInput',
    '_Job_employmentType_OrderByInput',
    '_Job_status_OrderByInput',
    '_Job_requirements_OrderByInput',
    '_Job_responsibilities_OrderByInput',
    '_Job_benefits_OrderByInput',
    '_Job_industry_OrderByInput',
    '_Job_tenantId_OrderByInput',
    '_Job_userId_OrderByInput',
    '_Job_companyId_OrderByInput',
    '_Job_createdById_OrderByInput',
    '_Job_updatedById_OrderByInput',
    '_Job_createdAt_OrderByInput',
    '_Job_updatedAt_OrderByInput',
    '_Job_deletedAt_OrderByInput',
    '_Job_deleted_OrderByInput',
    '_Job_RelevanceOrderByInput',
]



# recursive Job types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

JobRelationFilter = TypedDict(
    'JobRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class JobListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class JobInclude(TypedDict, total=False):
    """Job relational arguments"""
    tenant: Union[bool, 'TenantArgsFromJob']
    user: Union[bool, 'UserArgsFromJob']
    company: Union[bool, 'CompanyArgsFromJob']
    candidates: Union[bool, 'FindManyCandidateArgsFromJob']
    createdBy: Union[bool, 'UserArgsFromJob']
    updatedBy: Union[bool, 'UserArgsFromJob']


    

class TenantIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    users: Union[bool, 'FindManyUserArgsFromJobRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive1']
    createdBy: Union[bool, 'UserArgsFromJobRecursive1']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive1']


class TenantIncludeFromJobRecursive1(TypedDict, total=False):
    """Relational arguments for Job"""
    users: Union[bool, 'FindManyUserArgsFromJobRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive2']
    createdBy: Union[bool, 'UserArgsFromJobRecursive2']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive2']


class TenantIncludeFromJobRecursive2(TypedDict, total=False):
    """Relational arguments for Job"""
    users: Union[bool, 'FindManyUserArgsFromJobRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive3']
    createdBy: Union[bool, 'UserArgsFromJobRecursive3']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive3']


class TenantIncludeFromJobRecursive3(TypedDict, total=False):
    """Relational arguments for Job"""
    users: Union[bool, 'FindManyUserArgsFromJobRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive4']
    createdBy: Union[bool, 'UserArgsFromJobRecursive4']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive4']


class TenantIncludeFromJobRecursive4(TypedDict, total=False):
    """Relational arguments for Job"""

    

class TenantArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'TenantIncludeFromTenantRecursive1'


class TenantArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    include: 'TenantIncludeFromTenantRecursive2'


class TenantArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    include: 'TenantIncludeFromTenantRecursive3'


class TenantArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    include: 'TenantIncludeFromTenantRecursive4'


class TenantArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    
    

class FindManyTenantArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive1'


class FindManyTenantArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive2'


class FindManyTenantArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive3'


class FindManyTenantArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive4'


class FindManyTenantArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    
    

class UserIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive1']
    createdBy: Union[bool, 'UserArgsFromJobRecursive1']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive1']
    createdTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive1']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive1']
    createdUsers: Union[bool, 'FindManyUserArgsFromJobRecursive1']
    updatedUsers: Union[bool, 'FindManyUserArgsFromJobRecursive1']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']
    createdSearches: Union[bool, 'FindManySearchArgsFromJobRecursive1']
    updatedSearches: Union[bool, 'FindManySearchArgsFromJobRecursive1']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']
    createdJobs: Union[bool, 'FindManyJobArgsFromJobRecursive1']
    updatedJobs: Union[bool, 'FindManyJobArgsFromJobRecursive1']


class UserIncludeFromJobRecursive1(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive2']
    createdBy: Union[bool, 'UserArgsFromJobRecursive2']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive2']
    createdTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive2']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive2']
    createdUsers: Union[bool, 'FindManyUserArgsFromJobRecursive2']
    updatedUsers: Union[bool, 'FindManyUserArgsFromJobRecursive2']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']
    createdSearches: Union[bool, 'FindManySearchArgsFromJobRecursive2']
    updatedSearches: Union[bool, 'FindManySearchArgsFromJobRecursive2']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']
    createdJobs: Union[bool, 'FindManyJobArgsFromJobRecursive2']
    updatedJobs: Union[bool, 'FindManyJobArgsFromJobRecursive2']


class UserIncludeFromJobRecursive2(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive3']
    createdBy: Union[bool, 'UserArgsFromJobRecursive3']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive3']
    createdTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive3']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive3']
    createdUsers: Union[bool, 'FindManyUserArgsFromJobRecursive3']
    updatedUsers: Union[bool, 'FindManyUserArgsFromJobRecursive3']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']
    createdSearches: Union[bool, 'FindManySearchArgsFromJobRecursive3']
    updatedSearches: Union[bool, 'FindManySearchArgsFromJobRecursive3']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']
    createdJobs: Union[bool, 'FindManyJobArgsFromJobRecursive3']
    updatedJobs: Union[bool, 'FindManyJobArgsFromJobRecursive3']


class UserIncludeFromJobRecursive3(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive4']
    createdBy: Union[bool, 'UserArgsFromJobRecursive4']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive4']
    createdTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive4']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromJobRecursive4']
    createdUsers: Union[bool, 'FindManyUserArgsFromJobRecursive4']
    updatedUsers: Union[bool, 'FindManyUserArgsFromJobRecursive4']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']
    createdSearches: Union[bool, 'FindManySearchArgsFromJobRecursive4']
    updatedSearches: Union[bool, 'FindManySearchArgsFromJobRecursive4']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']
    createdJobs: Union[bool, 'FindManyJobArgsFromJobRecursive4']
    updatedJobs: Union[bool, 'FindManyJobArgsFromJobRecursive4']


class UserIncludeFromJobRecursive4(TypedDict, total=False):
    """Relational arguments for Job"""

    

class UserArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    
    

class FindManyUserArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class CandidateIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive1']
    user: Union[bool, 'UserArgsFromJobRecursive1']
    lastTouchedBy: Union[bool, 'UserArgsFromJobRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive1']
    createdBy: Union[bool, 'UserArgsFromJobRecursive1']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive1']


class CandidateIncludeFromJobRecursive1(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive2']
    user: Union[bool, 'UserArgsFromJobRecursive2']
    lastTouchedBy: Union[bool, 'UserArgsFromJobRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive2']
    createdBy: Union[bool, 'UserArgsFromJobRecursive2']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive2']


class CandidateIncludeFromJobRecursive2(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive3']
    user: Union[bool, 'UserArgsFromJobRecursive3']
    lastTouchedBy: Union[bool, 'UserArgsFromJobRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive3']
    createdBy: Union[bool, 'UserArgsFromJobRecursive3']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive3']


class CandidateIncludeFromJobRecursive3(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive4']
    user: Union[bool, 'UserArgsFromJobRecursive4']
    lastTouchedBy: Union[bool, 'UserArgsFromJobRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromJobRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromJobRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive4']
    createdBy: Union[bool, 'UserArgsFromJobRecursive4']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive4']


class CandidateIncludeFromJobRecursive4(TypedDict, total=False):
    """Relational arguments for Job"""

    

class CandidateArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CandidateIncludeFromCandidateRecursive1'


class CandidateArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CandidateIncludeFromCandidateRecursive2'


class CandidateArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CandidateIncludeFromCandidateRecursive3'


class CandidateArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CandidateIncludeFromCandidateRecursive4'


class CandidateArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    
    

class FindManyCandidateArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive1'


class FindManyCandidateArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive2'


class FindManyCandidateArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive3'


class FindManyCandidateArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive4'


class FindManyCandidateArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    
    

class SearchIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    user: Union[bool, 'UserArgsFromJobRecursive1']
    tenant: Union[bool, 'TenantArgsFromJobRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']
    createdBy: Union[bool, 'UserArgsFromJobRecursive1']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive1']


class SearchIncludeFromJobRecursive1(TypedDict, total=False):
    """Relational arguments for Job"""
    user: Union[bool, 'UserArgsFromJobRecursive2']
    tenant: Union[bool, 'TenantArgsFromJobRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']
    createdBy: Union[bool, 'UserArgsFromJobRecursive2']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive2']


class SearchIncludeFromJobRecursive2(TypedDict, total=False):
    """Relational arguments for Job"""
    user: Union[bool, 'UserArgsFromJobRecursive3']
    tenant: Union[bool, 'TenantArgsFromJobRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']
    createdBy: Union[bool, 'UserArgsFromJobRecursive3']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive3']


class SearchIncludeFromJobRecursive3(TypedDict, total=False):
    """Relational arguments for Job"""
    user: Union[bool, 'UserArgsFromJobRecursive4']
    tenant: Union[bool, 'TenantArgsFromJobRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']
    createdBy: Union[bool, 'UserArgsFromJobRecursive4']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive4']


class SearchIncludeFromJobRecursive4(TypedDict, total=False):
    """Relational arguments for Job"""

    

class SearchArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'SearchIncludeFromSearchRecursive1'


class SearchArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    include: 'SearchIncludeFromSearchRecursive2'


class SearchArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    include: 'SearchIncludeFromSearchRecursive3'


class SearchArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    include: 'SearchIncludeFromSearchRecursive4'


class SearchArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    
    

class FindManySearchArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive1'


class FindManySearchArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive2'


class FindManySearchArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive3'


class FindManySearchArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive4'


class FindManySearchArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    
    

class JobIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive1']
    user: Union[bool, 'UserArgsFromJobRecursive1']
    company: Union[bool, 'CompanyArgsFromJobRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']
    createdBy: Union[bool, 'UserArgsFromJobRecursive1']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive1']


class JobIncludeFromJobRecursive1(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive2']
    user: Union[bool, 'UserArgsFromJobRecursive2']
    company: Union[bool, 'CompanyArgsFromJobRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']
    createdBy: Union[bool, 'UserArgsFromJobRecursive2']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive2']


class JobIncludeFromJobRecursive2(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive3']
    user: Union[bool, 'UserArgsFromJobRecursive3']
    company: Union[bool, 'CompanyArgsFromJobRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']
    createdBy: Union[bool, 'UserArgsFromJobRecursive3']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive3']


class JobIncludeFromJobRecursive3(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive4']
    user: Union[bool, 'UserArgsFromJobRecursive4']
    company: Union[bool, 'CompanyArgsFromJobRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']
    createdBy: Union[bool, 'UserArgsFromJobRecursive4']
    updatedBy: Union[bool, 'UserArgsFromJobRecursive4']


class JobIncludeFromJobRecursive4(TypedDict, total=False):
    """Relational arguments for Job"""

    

class JobArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'JobIncludeFromJobRecursive1'


class JobArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    include: 'JobIncludeFromJobRecursive2'


class JobArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    include: 'JobIncludeFromJobRecursive3'


class JobArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    include: 'JobIncludeFromJobRecursive4'


class JobArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    
    

class FindManyJobArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive1'


class FindManyJobArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive2'


class FindManyJobArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive3'


class FindManyJobArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive4'


class FindManyJobArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    
    

class CompanyIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive1']


class CompanyIncludeFromJobRecursive1(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive2']


class CompanyIncludeFromJobRecursive2(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive3']


class CompanyIncludeFromJobRecursive3(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJobRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromJobRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobRecursive4']


class CompanyIncludeFromJobRecursive4(TypedDict, total=False):
    """Relational arguments for Job"""

    

class CompanyArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CompanyIncludeFromCompanyRecursive1'


class CompanyArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CompanyIncludeFromCompanyRecursive2'


class CompanyArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CompanyIncludeFromCompanyRecursive3'


class CompanyArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CompanyIncludeFromCompanyRecursive4'


class CompanyArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    
    

class FindManyCompanyArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive1'


class FindManyCompanyArgsFromJobRecursive1(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive2'


class FindManyCompanyArgsFromJobRecursive2(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive3'


class FindManyCompanyArgsFromJobRecursive3(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive4'


class FindManyCompanyArgsFromJobRecursive4(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    


FindManyJobArgs = FindManyJobArgsFromJob
FindFirstJobArgs = FindManyJobArgsFromJob


    

class JobWhereInput(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    salaryMin: Union[None, _int, 'types.IntFilter']
    salaryMax: Union[None, _int, 'types.IntFilter']
    employmentType: Union[None, _str, 'types.StringFilter']
    status: 'enums.JobStatus'
    requirements: Union[None, _str, 'types.StringFilter']
    responsibilities: Union[None, _str, 'types.StringFilter']
    benefits: Union[None, _str, 'types.StringFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    companyId: Union[_str, 'types.StringFilter']
    company: 'CompanyRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['JobWhereInputRecursive1', List['JobWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['JobWhereInputRecursive1']
    OR: List['JobWhereInputRecursive1']
    NOT: List['JobWhereInputRecursive1']


class JobWhereInputRecursive1(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    salaryMin: Union[None, _int, 'types.IntFilter']
    salaryMax: Union[None, _int, 'types.IntFilter']
    employmentType: Union[None, _str, 'types.StringFilter']
    status: 'enums.JobStatus'
    requirements: Union[None, _str, 'types.StringFilter']
    responsibilities: Union[None, _str, 'types.StringFilter']
    benefits: Union[None, _str, 'types.StringFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    companyId: Union[_str, 'types.StringFilter']
    company: 'CompanyRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['JobWhereInputRecursive2', List['JobWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['JobWhereInputRecursive2']
    OR: List['JobWhereInputRecursive2']
    NOT: List['JobWhereInputRecursive2']


class JobWhereInputRecursive2(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    salaryMin: Union[None, _int, 'types.IntFilter']
    salaryMax: Union[None, _int, 'types.IntFilter']
    employmentType: Union[None, _str, 'types.StringFilter']
    status: 'enums.JobStatus'
    requirements: Union[None, _str, 'types.StringFilter']
    responsibilities: Union[None, _str, 'types.StringFilter']
    benefits: Union[None, _str, 'types.StringFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    companyId: Union[_str, 'types.StringFilter']
    company: 'CompanyRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['JobWhereInputRecursive3', List['JobWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['JobWhereInputRecursive3']
    OR: List['JobWhereInputRecursive3']
    NOT: List['JobWhereInputRecursive3']


class JobWhereInputRecursive3(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    salaryMin: Union[None, _int, 'types.IntFilter']
    salaryMax: Union[None, _int, 'types.IntFilter']
    employmentType: Union[None, _str, 'types.StringFilter']
    status: 'enums.JobStatus'
    requirements: Union[None, _str, 'types.StringFilter']
    responsibilities: Union[None, _str, 'types.StringFilter']
    benefits: Union[None, _str, 'types.StringFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    companyId: Union[_str, 'types.StringFilter']
    company: 'CompanyRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['JobWhereInputRecursive4', List['JobWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['JobWhereInputRecursive4']
    OR: List['JobWhereInputRecursive4']
    NOT: List['JobWhereInputRecursive4']


class JobWhereInputRecursive4(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    location: Union[None, _str, 'types.StringFilter']
    salaryMin: Union[None, _int, 'types.IntFilter']
    salaryMax: Union[None, _int, 'types.IntFilter']
    employmentType: Union[None, _str, 'types.StringFilter']
    status: 'enums.JobStatus'
    requirements: Union[None, _str, 'types.StringFilter']
    responsibilities: Union[None, _str, 'types.StringFilter']
    benefits: Union[None, _str, 'types.StringFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    companyId: Union[_str, 'types.StringFilter']
    company: 'CompanyRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdById: Union[None, _str, 'types.StringFilter']
    updatedById: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    updatedBy: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']



# aggregate Job types


    

class JobScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    salaryMin: Union[_int, 'types.IntWithAggregatesFilter']
    salaryMax: Union[_int, 'types.IntWithAggregatesFilter']
    employmentType: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.JobStatus'
    requirements: Union[_str, 'types.StringWithAggregatesFilter']
    responsibilities: Union[_str, 'types.StringWithAggregatesFilter']
    benefits: Union[_str, 'types.StringWithAggregatesFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    companyId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['JobScalarWhereWithAggregatesInputRecursive1']
    OR: List['JobScalarWhereWithAggregatesInputRecursive1']
    NOT: List['JobScalarWhereWithAggregatesInputRecursive1']


class JobScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    salaryMin: Union[_int, 'types.IntWithAggregatesFilter']
    salaryMax: Union[_int, 'types.IntWithAggregatesFilter']
    employmentType: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.JobStatus'
    requirements: Union[_str, 'types.StringWithAggregatesFilter']
    responsibilities: Union[_str, 'types.StringWithAggregatesFilter']
    benefits: Union[_str, 'types.StringWithAggregatesFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    companyId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['JobScalarWhereWithAggregatesInputRecursive2']
    OR: List['JobScalarWhereWithAggregatesInputRecursive2']
    NOT: List['JobScalarWhereWithAggregatesInputRecursive2']


class JobScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    salaryMin: Union[_int, 'types.IntWithAggregatesFilter']
    salaryMax: Union[_int, 'types.IntWithAggregatesFilter']
    employmentType: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.JobStatus'
    requirements: Union[_str, 'types.StringWithAggregatesFilter']
    responsibilities: Union[_str, 'types.StringWithAggregatesFilter']
    benefits: Union[_str, 'types.StringWithAggregatesFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    companyId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['JobScalarWhereWithAggregatesInputRecursive3']
    OR: List['JobScalarWhereWithAggregatesInputRecursive3']
    NOT: List['JobScalarWhereWithAggregatesInputRecursive3']


class JobScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    salaryMin: Union[_int, 'types.IntWithAggregatesFilter']
    salaryMax: Union[_int, 'types.IntWithAggregatesFilter']
    employmentType: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.JobStatus'
    requirements: Union[_str, 'types.StringWithAggregatesFilter']
    responsibilities: Union[_str, 'types.StringWithAggregatesFilter']
    benefits: Union[_str, 'types.StringWithAggregatesFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    companyId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['JobScalarWhereWithAggregatesInputRecursive4']
    OR: List['JobScalarWhereWithAggregatesInputRecursive4']
    NOT: List['JobScalarWhereWithAggregatesInputRecursive4']


class JobScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    salaryMin: Union[_int, 'types.IntWithAggregatesFilter']
    salaryMax: Union[_int, 'types.IntWithAggregatesFilter']
    employmentType: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.JobStatus'
    requirements: Union[_str, 'types.StringWithAggregatesFilter']
    responsibilities: Union[_str, 'types.StringWithAggregatesFilter']
    benefits: Union[_str, 'types.StringWithAggregatesFilter']
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    companyId: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_str, 'types.StringWithAggregatesFilter']
    updatedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']



class JobGroupByOutput(TypedDict, total=False):
    id: _str
    title: _str
    description: _str
    location: _str
    salaryMin: _int
    salaryMax: _int
    employmentType: _str
    status: 'enums.JobStatus'
    requirements: _str
    responsibilities: _str
    benefits: _str
    industry: 'enums.Industry'
    tenantId: _str
    userId: _str
    companyId: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool
    _sum: 'JobSumAggregateOutput'
    _avg: 'JobAvgAggregateOutput'
    _min: 'JobMinAggregateOutput'
    _max: 'JobMaxAggregateOutput'
    _count: 'JobCountAggregateOutput'


class JobAvgAggregateOutput(TypedDict, total=False):
    """Job output for aggregating averages"""
    salaryMin: float
    salaryMax: float


class JobSumAggregateOutput(TypedDict, total=False):
    """Job output for aggregating sums"""
    salaryMin: _int
    salaryMax: _int


class JobScalarAggregateOutput(TypedDict, total=False):
    """Job output including scalar fields"""
    id: _str
    title: _str
    description: _str
    location: _str
    salaryMin: _int
    salaryMax: _int
    employmentType: _str
    status: 'enums.JobStatus'
    requirements: _str
    responsibilities: _str
    benefits: _str
    industry: 'enums.Industry'
    tenantId: _str
    userId: _str
    companyId: _str
    createdById: _str
    updatedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool


JobMinAggregateOutput = JobScalarAggregateOutput
JobMaxAggregateOutput = JobScalarAggregateOutput


class JobMaxAggregateInput(TypedDict, total=False):
    """Job input for aggregating by max"""
    id: bool
    title: bool
    description: bool
    location: bool
    salaryMin: bool
    salaryMax: bool
    employmentType: bool
    status: bool
    requirements: bool
    responsibilities: bool
    benefits: bool
    industry: bool
    tenantId: bool
    userId: bool
    companyId: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class JobMinAggregateInput(TypedDict, total=False):
    """Job input for aggregating by min"""
    id: bool
    title: bool
    description: bool
    location: bool
    salaryMin: bool
    salaryMax: bool
    employmentType: bool
    status: bool
    requirements: bool
    responsibilities: bool
    benefits: bool
    industry: bool
    tenantId: bool
    userId: bool
    companyId: bool
    createdById: bool
    updatedById: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class JobNumberAggregateInput(TypedDict, total=False):
    """Job input for aggregating numbers"""
    salaryMin: bool
    salaryMax: bool


JobAvgAggregateInput = JobNumberAggregateInput
JobSumAggregateInput = JobNumberAggregateInput


JobCountAggregateInput = TypedDict(
    'JobCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'description': bool,
        'location': bool,
        'salaryMin': bool,
        'salaryMax': bool,
        'employmentType': bool,
        'status': bool,
        'requirements': bool,
        'responsibilities': bool,
        'benefits': bool,
        'industry': bool,
        'tenantId': bool,
        'userId': bool,
        'companyId': bool,
        'createdById': bool,
        'updatedById': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deletedAt': bool,
        'deleted': bool,
        '_all': bool,
    },
    total=False,
)

JobCountAggregateOutput = TypedDict(
    'JobCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'description': int,
        'location': int,
        'salaryMin': int,
        'salaryMax': int,
        'employmentType': int,
        'status': int,
        'requirements': int,
        'responsibilities': int,
        'benefits': int,
        'industry': int,
        'tenantId': int,
        'userId': int,
        'companyId': int,
        'createdById': int,
        'updatedById': int,
        'createdAt': int,
        'updatedAt': int,
        'deletedAt': int,
        'deleted': int,
        '_all': int,
    },
    total=False,
)


JobKeys = Literal[
    'id',
    'title',
    'description',
    'location',
    'salaryMin',
    'salaryMax',
    'employmentType',
    'status',
    'requirements',
    'responsibilities',
    'benefits',
    'industry',
    'tenantId',
    'tenant',
    'userId',
    'user',
    'companyId',
    'company',
    'candidates',
    'createdById',
    'updatedById',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
JobScalarFieldKeys = Literal[
    'id',
    'title',
    'description',
    'location',
    'salaryMin',
    'salaryMax',
    'employmentType',
    'status',
    'requirements',
    'responsibilities',
    'benefits',
    'industry',
    'tenantId',
    'userId',
    'companyId',
    'createdById',
    'updatedById',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
JobScalarFieldKeysT = TypeVar('JobScalarFieldKeysT', bound=JobScalarFieldKeys)

JobRelationalFieldKeys = Literal[
        'tenant',
        'user',
        'company',
        'candidates',
        'createdBy',
        'updatedBy',
    ]

# Company types

class CompanyOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Company create method"""
    id: _str
    logo: Optional[_str]
    url: Optional[_str]
    stage: Optional['enums.CompanyStage']
    size: Optional['enums.CompanySize']
    industry: Optional['enums.Industry']
    tenantId: _str
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    jobs: 'JobCreateManyNestedWithoutRelationsInput'
    candidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CompanyCreateInput(CompanyOptionalCreateInput):
    """Required arguments to the Company create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CompanyOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Company create method, without relations"""
    id: _str
    logo: Optional[_str]
    url: Optional[_str]
    stage: Optional['enums.CompanyStage']
    size: Optional['enums.CompanySize']
    industry: Optional['enums.Industry']
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CompanyCreateWithoutRelationsInput(CompanyOptionalCreateWithoutRelationsInput):
    """Required arguments to the Company create method, without relations"""
    name: _str

class CompanyConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CompanyCreateWithoutRelationsInput'
    where: 'CompanyWhereUniqueInput'

class CompanyCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CompanyCreateWithoutRelationsInput'
    connect: 'CompanyWhereUniqueInput'
    connect_or_create: 'CompanyConnectOrCreateWithoutRelationsInput'


class CompanyCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CompanyCreateWithoutRelationsInput', List['CompanyCreateWithoutRelationsInput']]
    connect: Union['CompanyWhereUniqueInput', List['CompanyWhereUniqueInput']]
    connect_or_create: Union['CompanyConnectOrCreateWithoutRelationsInput', List['CompanyConnectOrCreateWithoutRelationsInput']]

_CompanyWhereUnique_id_Input = TypedDict(
    '_CompanyWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_CompanyCompoundunique_company_name_tenantKeyInner = TypedDict(
    '_CompanyCompoundunique_company_name_tenantKeyInner',
    {
        'tenantId': '_str',
        'name': '_str',
        'deletedAt': 'datetime.datetime',
    },
    total=True
)

_CompanyCompoundunique_company_name_tenantKey = TypedDict(
    '_CompanyCompoundunique_company_name_tenantKey',
    {
        'unique_company_name_tenant': '_CompanyCompoundunique_company_name_tenantKeyInner',
    },
    total=True
)

CompanyWhereUniqueInput = Union[
    '_CompanyWhereUnique_id_Input',
    '_CompanyCompoundunique_company_name_tenantKey',
]


class CompanyUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    logo: Optional[_str]
    url: Optional[_str]
    stage: Optional['enums.CompanyStage']
    size: Optional['enums.CompanySize']
    industry: Optional['enums.Industry']
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    jobs: 'JobUpdateManyWithoutRelationsInput'
    candidates: 'CandidateUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CompanyUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    logo: Optional[_str]
    url: Optional[_str]
    stage: Optional['enums.CompanyStage']
    size: Optional['enums.CompanySize']
    industry: Optional['enums.Industry']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deleted: _bool


class CompanyUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CompanyCreateWithoutRelationsInput']
    connect: List['CompanyWhereUniqueInput']
    connect_or_create: List['CompanyConnectOrCreateWithoutRelationsInput']
    set: List['CompanyWhereUniqueInput']
    disconnect: List['CompanyWhereUniqueInput']
    delete: List['CompanyWhereUniqueInput']

    # TODO
    # update: List['CompanyUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CompanyUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CompanyScalarWhereInput']
    # upsert: List['CompanyUpserteWithWhereUniqueWithoutRelationsInput']


class CompanyUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CompanyCreateWithoutRelationsInput'
    connect: 'CompanyWhereUniqueInput'
    connect_or_create: 'CompanyConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CompanyUpdateInput'
    # upsert: 'CompanyUpsertWithoutRelationsInput'


class CompanyUpsertInput(TypedDict):
    create: 'CompanyCreateInput'
    update: 'CompanyUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Company_id_OrderByInput = TypedDict(
    '_Company_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Company_name_OrderByInput = TypedDict(
    '_Company_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Company_logo_OrderByInput = TypedDict(
    '_Company_logo_OrderByInput',
    {
        'logo': 'SortOrder',
    },
    total=True
)

_Company_url_OrderByInput = TypedDict(
    '_Company_url_OrderByInput',
    {
        'url': 'SortOrder',
    },
    total=True
)

_Company_stage_OrderByInput = TypedDict(
    '_Company_stage_OrderByInput',
    {
        'stage': 'SortOrder',
    },
    total=True
)

_Company_size_OrderByInput = TypedDict(
    '_Company_size_OrderByInput',
    {
        'size': 'SortOrder',
    },
    total=True
)

_Company_industry_OrderByInput = TypedDict(
    '_Company_industry_OrderByInput',
    {
        'industry': 'SortOrder',
    },
    total=True
)

_Company_tenantId_OrderByInput = TypedDict(
    '_Company_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Company_createdAt_OrderByInput = TypedDict(
    '_Company_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Company_updatedAt_OrderByInput = TypedDict(
    '_Company_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Company_deletedAt_OrderByInput = TypedDict(
    '_Company_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Company_deleted_OrderByInput = TypedDict(
    '_Company_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Company_RelevanceInner = TypedDict(
    '_Company_RelevanceInner',
    {
        'fields': 'List[CompanyScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Company_RelevanceOrderByInput = TypedDict(
    '_Company_RelevanceOrderByInput',
    {
        '_relevance': '_Company_RelevanceInner',
    },
    total=True
)

CompanyOrderByInput = Union[
    '_Company_id_OrderByInput',
    '_Company_name_OrderByInput',
    '_Company_logo_OrderByInput',
    '_Company_url_OrderByInput',
    '_Company_stage_OrderByInput',
    '_Company_size_OrderByInput',
    '_Company_industry_OrderByInput',
    '_Company_tenantId_OrderByInput',
    '_Company_createdAt_OrderByInput',
    '_Company_updatedAt_OrderByInput',
    '_Company_deletedAt_OrderByInput',
    '_Company_deleted_OrderByInput',
    '_Company_RelevanceOrderByInput',
]



# recursive Company types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CompanyRelationFilter = TypedDict(
    'CompanyRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CompanyListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CompanyInclude(TypedDict, total=False):
    """Company relational arguments"""
    tenant: Union[bool, 'TenantArgsFromCompany']
    jobs: Union[bool, 'FindManyJobArgsFromCompany']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompany']


    

class TenantIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    users: Union[bool, 'FindManyUserArgsFromCompanyRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive1']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive1']


class TenantIncludeFromCompanyRecursive1(TypedDict, total=False):
    """Relational arguments for Company"""
    users: Union[bool, 'FindManyUserArgsFromCompanyRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive2']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive2']


class TenantIncludeFromCompanyRecursive2(TypedDict, total=False):
    """Relational arguments for Company"""
    users: Union[bool, 'FindManyUserArgsFromCompanyRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive3']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive3']


class TenantIncludeFromCompanyRecursive3(TypedDict, total=False):
    """Relational arguments for Company"""
    users: Union[bool, 'FindManyUserArgsFromCompanyRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive4']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive4']


class TenantIncludeFromCompanyRecursive4(TypedDict, total=False):
    """Relational arguments for Company"""

    

class TenantArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'TenantIncludeFromTenantRecursive1'


class TenantArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    include: 'TenantIncludeFromTenantRecursive2'


class TenantArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    include: 'TenantIncludeFromTenantRecursive3'


class TenantArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    include: 'TenantIncludeFromTenantRecursive4'


class TenantArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    
    

class FindManyTenantArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive1'


class FindManyTenantArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive2'


class FindManyTenantArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive3'


class FindManyTenantArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenantRecursive4'


class FindManyTenantArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    
    

class UserIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive1']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive1']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive1']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive1']
    createdUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive1']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive1']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']
    createdSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive1']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive1']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']
    createdJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive1']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive1']


class UserIncludeFromCompanyRecursive1(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive2']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive2']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive2']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive2']
    createdUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive2']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive2']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']
    createdSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive2']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive2']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']
    createdJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive2']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive2']


class UserIncludeFromCompanyRecursive2(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive3']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive3']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive3']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive3']
    createdUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive3']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive3']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']
    createdSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive3']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive3']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']
    createdJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive3']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive3']


class UserIncludeFromCompanyRecursive3(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive4']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive4']
    createdTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive4']
    updatedTenants: Union[bool, 'FindManyTenantArgsFromCompanyRecursive4']
    createdUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive4']
    updatedUsers: Union[bool, 'FindManyUserArgsFromCompanyRecursive4']
    createdCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']
    updatedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']
    createdSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive4']
    updatedSearches: Union[bool, 'FindManySearchArgsFromCompanyRecursive4']
    touchedCandidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']
    createdJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive4']
    updatedJobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive4']


class UserIncludeFromCompanyRecursive4(TypedDict, total=False):
    """Relational arguments for Company"""

    

class UserArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    
    

class FindManyUserArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class CandidateIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive1']
    user: Union[bool, 'UserArgsFromCompanyRecursive1']
    lastTouchedBy: Union[bool, 'UserArgsFromCompanyRecursive1']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive1']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive1']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive1']


class CandidateIncludeFromCompanyRecursive1(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive2']
    user: Union[bool, 'UserArgsFromCompanyRecursive2']
    lastTouchedBy: Union[bool, 'UserArgsFromCompanyRecursive2']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive2']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive2']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive2']


class CandidateIncludeFromCompanyRecursive2(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive3']
    user: Union[bool, 'UserArgsFromCompanyRecursive3']
    lastTouchedBy: Union[bool, 'UserArgsFromCompanyRecursive3']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive3']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive3']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive3']


class CandidateIncludeFromCompanyRecursive3(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive4']
    user: Union[bool, 'UserArgsFromCompanyRecursive4']
    lastTouchedBy: Union[bool, 'UserArgsFromCompanyRecursive4']
    searches: Union[bool, 'FindManySearchArgsFromCompanyRecursive4']
    companies: Union[bool, 'FindManyCompanyArgsFromCompanyRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive4']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive4']


class CandidateIncludeFromCompanyRecursive4(TypedDict, total=False):
    """Relational arguments for Company"""

    

class CandidateArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CandidateIncludeFromCandidateRecursive1'


class CandidateArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CandidateIncludeFromCandidateRecursive2'


class CandidateArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CandidateIncludeFromCandidateRecursive3'


class CandidateArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CandidateIncludeFromCandidateRecursive4'


class CandidateArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    
    

class FindManyCandidateArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive1'


class FindManyCandidateArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive2'


class FindManyCandidateArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive3'


class FindManyCandidateArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidateRecursive4'


class FindManyCandidateArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    
    

class SearchIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    user: Union[bool, 'UserArgsFromCompanyRecursive1']
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive1']


class SearchIncludeFromCompanyRecursive1(TypedDict, total=False):
    """Relational arguments for Company"""
    user: Union[bool, 'UserArgsFromCompanyRecursive2']
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive2']


class SearchIncludeFromCompanyRecursive2(TypedDict, total=False):
    """Relational arguments for Company"""
    user: Union[bool, 'UserArgsFromCompanyRecursive3']
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive3']


class SearchIncludeFromCompanyRecursive3(TypedDict, total=False):
    """Relational arguments for Company"""
    user: Union[bool, 'UserArgsFromCompanyRecursive4']
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive4']


class SearchIncludeFromCompanyRecursive4(TypedDict, total=False):
    """Relational arguments for Company"""

    

class SearchArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'SearchIncludeFromSearchRecursive1'


class SearchArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    include: 'SearchIncludeFromSearchRecursive2'


class SearchArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    include: 'SearchIncludeFromSearchRecursive3'


class SearchArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    include: 'SearchIncludeFromSearchRecursive4'


class SearchArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    
    

class FindManySearchArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive1'


class FindManySearchArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive2'


class FindManySearchArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive3'


class FindManySearchArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    include: 'SearchIncludeFromSearchRecursive4'


class FindManySearchArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['SearchOrderByInput', List['SearchOrderByInput']]
    where: 'SearchWhereInput'
    cursor: 'SearchWhereUniqueInput'
    distinct: List['SearchScalarFieldKeys']
    
    

class JobIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive1']
    user: Union[bool, 'UserArgsFromCompanyRecursive1']
    company: Union[bool, 'CompanyArgsFromCompanyRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive1']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive1']


class JobIncludeFromCompanyRecursive1(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive2']
    user: Union[bool, 'UserArgsFromCompanyRecursive2']
    company: Union[bool, 'CompanyArgsFromCompanyRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive2']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive2']


class JobIncludeFromCompanyRecursive2(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive3']
    user: Union[bool, 'UserArgsFromCompanyRecursive3']
    company: Union[bool, 'CompanyArgsFromCompanyRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive3']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive3']


class JobIncludeFromCompanyRecursive3(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive4']
    user: Union[bool, 'UserArgsFromCompanyRecursive4']
    company: Union[bool, 'CompanyArgsFromCompanyRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']
    createdBy: Union[bool, 'UserArgsFromCompanyRecursive4']
    updatedBy: Union[bool, 'UserArgsFromCompanyRecursive4']


class JobIncludeFromCompanyRecursive4(TypedDict, total=False):
    """Relational arguments for Company"""

    

class JobArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'JobIncludeFromJobRecursive1'


class JobArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    include: 'JobIncludeFromJobRecursive2'


class JobArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    include: 'JobIncludeFromJobRecursive3'


class JobArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    include: 'JobIncludeFromJobRecursive4'


class JobArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    
    

class FindManyJobArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive1'


class FindManyJobArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive2'


class FindManyJobArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive3'


class FindManyJobArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJobRecursive4'


class FindManyJobArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    
    

class CompanyIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive1']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive1']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive1']


class CompanyIncludeFromCompanyRecursive1(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive2']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive2']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive2']


class CompanyIncludeFromCompanyRecursive2(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive3']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive3']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive3']


class CompanyIncludeFromCompanyRecursive3(TypedDict, total=False):
    """Relational arguments for Company"""
    tenant: Union[bool, 'TenantArgsFromCompanyRecursive4']
    jobs: Union[bool, 'FindManyJobArgsFromCompanyRecursive4']
    candidates: Union[bool, 'FindManyCandidateArgsFromCompanyRecursive4']


class CompanyIncludeFromCompanyRecursive4(TypedDict, total=False):
    """Relational arguments for Company"""

    

class CompanyArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CompanyIncludeFromCompanyRecursive1'


class CompanyArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CompanyIncludeFromCompanyRecursive2'


class CompanyArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CompanyIncludeFromCompanyRecursive3'


class CompanyArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CompanyIncludeFromCompanyRecursive4'


class CompanyArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    
    

class FindManyCompanyArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive1'


class FindManyCompanyArgsFromCompanyRecursive1(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive2'


class FindManyCompanyArgsFromCompanyRecursive2(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive3'


class FindManyCompanyArgsFromCompanyRecursive3(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompanyRecursive4'


class FindManyCompanyArgsFromCompanyRecursive4(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    


FindManyCompanyArgs = FindManyCompanyArgsFromCompany
FindFirstCompanyArgs = FindManyCompanyArgsFromCompany


    

class CompanyWhereInput(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    logo: Union[None, _str, 'types.StringFilter']
    url: Union[None, _str, 'types.StringFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    jobs: 'JobListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CompanyWhereInputRecursive1', List['CompanyWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CompanyWhereInputRecursive1']
    OR: List['CompanyWhereInputRecursive1']
    NOT: List['CompanyWhereInputRecursive1']


class CompanyWhereInputRecursive1(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    logo: Union[None, _str, 'types.StringFilter']
    url: Union[None, _str, 'types.StringFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    jobs: 'JobListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CompanyWhereInputRecursive2', List['CompanyWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CompanyWhereInputRecursive2']
    OR: List['CompanyWhereInputRecursive2']
    NOT: List['CompanyWhereInputRecursive2']


class CompanyWhereInputRecursive2(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    logo: Union[None, _str, 'types.StringFilter']
    url: Union[None, _str, 'types.StringFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    jobs: 'JobListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CompanyWhereInputRecursive3', List['CompanyWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CompanyWhereInputRecursive3']
    OR: List['CompanyWhereInputRecursive3']
    NOT: List['CompanyWhereInputRecursive3']


class CompanyWhereInputRecursive3(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    logo: Union[None, _str, 'types.StringFilter']
    url: Union[None, _str, 'types.StringFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    jobs: 'JobListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['CompanyWhereInputRecursive4', List['CompanyWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CompanyWhereInputRecursive4']
    OR: List['CompanyWhereInputRecursive4']
    NOT: List['CompanyWhereInputRecursive4']


class CompanyWhereInputRecursive4(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    logo: Union[None, _str, 'types.StringFilter']
    url: Union[None, _str, 'types.StringFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    jobs: 'JobListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']



# aggregate Company types


    

class CompanyScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    logo: Union[_str, 'types.StringWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CompanyScalarWhereWithAggregatesInputRecursive1']
    OR: List['CompanyScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CompanyScalarWhereWithAggregatesInputRecursive1']


class CompanyScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    logo: Union[_str, 'types.StringWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CompanyScalarWhereWithAggregatesInputRecursive2']
    OR: List['CompanyScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CompanyScalarWhereWithAggregatesInputRecursive2']


class CompanyScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    logo: Union[_str, 'types.StringWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CompanyScalarWhereWithAggregatesInputRecursive3']
    OR: List['CompanyScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CompanyScalarWhereWithAggregatesInputRecursive3']


class CompanyScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    logo: Union[_str, 'types.StringWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['CompanyScalarWhereWithAggregatesInputRecursive4']
    OR: List['CompanyScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CompanyScalarWhereWithAggregatesInputRecursive4']


class CompanyScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    logo: Union[_str, 'types.StringWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']



class CompanyGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    logo: _str
    url: _str
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool
    _sum: 'CompanySumAggregateOutput'
    _avg: 'CompanyAvgAggregateOutput'
    _min: 'CompanyMinAggregateOutput'
    _max: 'CompanyMaxAggregateOutput'
    _count: 'CompanyCountAggregateOutput'


class CompanyAvgAggregateOutput(TypedDict, total=False):
    """Company output for aggregating averages"""


class CompanySumAggregateOutput(TypedDict, total=False):
    """Company output for aggregating sums"""


class CompanyScalarAggregateOutput(TypedDict, total=False):
    """Company output including scalar fields"""
    id: _str
    name: _str
    logo: _str
    url: _str
    stage: 'enums.CompanyStage'
    size: 'enums.CompanySize'
    industry: 'enums.Industry'
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deleted: _bool


CompanyMinAggregateOutput = CompanyScalarAggregateOutput
CompanyMaxAggregateOutput = CompanyScalarAggregateOutput


class CompanyMaxAggregateInput(TypedDict, total=False):
    """Company input for aggregating by max"""
    id: bool
    name: bool
    logo: bool
    url: bool
    stage: bool
    size: bool
    industry: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class CompanyMinAggregateInput(TypedDict, total=False):
    """Company input for aggregating by min"""
    id: bool
    name: bool
    logo: bool
    url: bool
    stage: bool
    size: bool
    industry: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deleted: bool


class CompanyNumberAggregateInput(TypedDict, total=False):
    """Company input for aggregating numbers"""


CompanyAvgAggregateInput = CompanyNumberAggregateInput
CompanySumAggregateInput = CompanyNumberAggregateInput


CompanyCountAggregateInput = TypedDict(
    'CompanyCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'logo': bool,
        'url': bool,
        'stage': bool,
        'size': bool,
        'industry': bool,
        'tenantId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deletedAt': bool,
        'deleted': bool,
        '_all': bool,
    },
    total=False,
)

CompanyCountAggregateOutput = TypedDict(
    'CompanyCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'logo': int,
        'url': int,
        'stage': int,
        'size': int,
        'industry': int,
        'tenantId': int,
        'createdAt': int,
        'updatedAt': int,
        'deletedAt': int,
        'deleted': int,
        '_all': int,
    },
    total=False,
)


CompanyKeys = Literal[
    'id',
    'name',
    'logo',
    'url',
    'stage',
    'size',
    'industry',
    'tenantId',
    'tenant',
    'jobs',
    'candidates',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
CompanyScalarFieldKeys = Literal[
    'id',
    'name',
    'logo',
    'url',
    'stage',
    'size',
    'industry',
    'tenantId',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deleted',
]
CompanyScalarFieldKeysT = TypeVar('CompanyScalarFieldKeysT', bound=CompanyScalarFieldKeys)

CompanyRelationalFieldKeys = Literal[
        'tenant',
        'jobs',
        'candidates',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields